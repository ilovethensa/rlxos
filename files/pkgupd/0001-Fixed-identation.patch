From af3ba1fe653fa3bc6ea233658b7b9653d4d00643 Mon Sep 17 00:00:00 2001
From: Manjeet Singh <itsmanjeet@pop-os.localdomain>
Date: Tue, 5 Oct 2021 00:36:37 +0530
Subject: [PATCH 1/3] Fixed identation

---
 libpkgupd/archive.cc    | 198 ++++++++++------------
 libpkgupd/archive.hh    |  81 +++++----
 libpkgupd/builder.cc    | 294 +++++++++++++++-----------------
 libpkgupd/builder.hh    |  96 +++++------
 libpkgupd/compiler.cc   | 196 ++++++++++------------
 libpkgupd/compiler.hh   |  80 +++++----
 libpkgupd/db.hh         |  27 ++-
 libpkgupd/defines.hh    |  38 ++---
 libpkgupd/downloader.cc | 241 +++++++++++++--------------
 libpkgupd/downloader.hh |  31 ++--
 libpkgupd/exec.hh       | 104 ++++++------
 libpkgupd/installer.cc  | 185 +++++++++-----------
 libpkgupd/installer.hh  |  61 ++++---
 libpkgupd/pkginfo.hh    |  27 ++-
 libpkgupd/recipe.cc     | 218 +++++++++++-------------
 libpkgupd/recipe.hh     | 265 ++++++++++++++---------------
 libpkgupd/remover.cc    | 128 +++++++-------
 libpkgupd/remover.hh    |  47 +++---
 libpkgupd/repodb.cc     | 113 ++++++-------
 libpkgupd/repodb.hh     |  23 ++-
 libpkgupd/resolver.cc   |  61 +++----
 libpkgupd/resolver.hh   |  47 +++---
 libpkgupd/stripper.cc   |  71 ++++----
 libpkgupd/stripper.hh   |  24 ++-
 libpkgupd/sysdb.cc      | 167 +++++++++----------
 libpkgupd/sysdb.hh      |  72 ++++----
 libpkgupd/triggerer.cc  | 191 +++++++++------------
 libpkgupd/triggerer.hh  |  72 ++++----
 pkgupd/PKGUPD.cc        | 361 ++++++++++++++++------------------------
 pkgupd/PKGUPD.hh        | 139 ++++++++--------
 pkgupd/main.cc          |   3 +-
 31 files changed, 1658 insertions(+), 2003 deletions(-)

diff --git a/libpkgupd/archive.cc b/libpkgupd/archive.cc
index fdf91e1..63192d8 100644
--- a/libpkgupd/archive.cc
+++ b/libpkgupd/archive.cc
@@ -1,140 +1,122 @@
 #include "archive.hh"
-#include "exec.hh"
 
 #include <fstream>
 
-namespace rlxos::libpkgupd
-{
+#include "exec.hh"
 
-    archive::package::package(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(std::string, id);
-        READ_VALUE(std::string, version);
-        READ_VALUE(std::string, about);
-        READ_LIST(std::string, depends);
-    }
+namespace rlxos::libpkgupd {
 
-    std::tuple<int, std::string> archive::getdata(std::string const &filepath)
-    {
-        std::string cmd = _archive_tool;
-        cmd += " --zstd -O -xf " + _pkgfile + " " + filepath;
+archive::package::package(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(std::string, id);
+    READ_VALUE(std::string, version);
+    READ_VALUE(std::string, about);
+    READ_LIST(std::string, depends);
+}
 
-        auto [status, output] = exec().output(cmd);
-        if (status != 0)
-        {
-            _error = "failed to get data from " + _pkgfile;
-            return {status, output};
-        }
+std::tuple<int, std::string> archive::getdata(std::string const &filepath) {
+    std::string cmd = _archive_tool;
+    cmd += " --zstd -O -xf " + _pkgfile + " " + filepath;
+
+    auto [status, output] = exec().output(cmd);
+    if (status != 0) {
+        _error = "failed to get data from " + _pkgfile;
         return {status, output};
     }
+    return {status, output};
+}
+
+std::shared_ptr<archive::package> archive::info() {
+    auto [status, content] = getdata("./info");
+    if (status != 0) {
+        _error = "failed to read package information";
+        return nullptr;
+    }
 
-    std::shared_ptr<archive::package> archive::info()
-    {
-        auto [status, content] = getdata("./info");
-        if (status != 0)
-        {
-            _error = "failed to read package information";
-            return nullptr;
-        }
-
-        DEBUG("info: " << content);
-        YAML::Node data;
-
-        try
-        {
-            data = YAML::Load(content);
-        }
-        catch (YAML::Exception const &e)
-        {
-            _error = "corrupt package data, " + std::string(e.what());
-            return nullptr;
-        }
+    DEBUG("info: " << content);
+    YAML::Node data;
 
-        return std::make_shared<archive::package>(data, _pkgfile);
+    try {
+        data = YAML::Load(content);
+    } catch (YAML::Exception const &e) {
+        _error = "corrupt package data, " + std::string(e.what());
+        return nullptr;
     }
 
-    std::vector<std::string> archive::list()
-    {
-        std::string cmd = _archive_tool;
-        cmd += " --zstd -tf " + _pkgfile;
+    return std::make_shared<archive::package>(data, _pkgfile);
+}
 
-        auto [status, output] = exec().output(cmd);
-        if (status != 0)
-        {
-            _error = output;
-            return {};
-        }
+std::vector<std::string> archive::list() {
+    std::string cmd = _archive_tool;
+    cmd += " --zstd -tf " + _pkgfile;
 
-        std::stringstream ss(output);
-        std::string file;
+    auto [status, output] = exec().output(cmd);
+    if (status != 0) {
+        _error = output;
+        return {};
+    }
 
-        std::vector<std::string> files_list;
+    std::stringstream ss(output);
+    std::string file;
 
-        while (std::getline(ss, file, '\n'))
-            files_list.push_back(file);
+    std::vector<std::string> files_list;
 
-        return files_list;
-    }
+    while (std::getline(ss, file, '\n'))
+        files_list.push_back(file);
 
-    bool archive::compress(std::string const &srcdir, std::shared_ptr<pkginfo> const &info)
-    {
-        std::string pardir = std::filesystem::path(_pkgfile).parent_path();
-        if (!std::filesystem::exists(pardir))
-        {
-            std::error_code err;
-            std::filesystem::create_directories(pardir, err);
-            if (err)
-            {
-                _error = "failed to create " + pardir + ", " + err.message();
-                return false;
-            }
+    return files_list;
+}
+
+bool archive::compress(std::string const &srcdir, std::shared_ptr<pkginfo> const &info) {
+    std::string pardir = std::filesystem::path(_pkgfile).parent_path();
+    if (!std::filesystem::exists(pardir)) {
+        std::error_code err;
+        std::filesystem::create_directories(pardir, err);
+        if (err) {
+            _error = "failed to create " + pardir + ", " + err.message();
+            return false;
         }
+    }
 
-        std::ofstream fileptr(srcdir + "/info");
+    std::ofstream fileptr(srcdir + "/info");
 
-        fileptr << "id: " << info->id() << "\n"
-                << "version: " << info->version() << "\n"
-                << "about: " << info->about() << "\n";
+    fileptr << "id: " << info->id() << "\n"
+            << "version: " << info->version() << "\n"
+            << "about: " << info->about() << "\n";
 
-        if (info->depends(false).size())
-        {
-            fileptr << "depends:"
-                    << "\n";
-            for (auto const &i : info->depends(false))
-                fileptr << " - " << i << "\n";
-        }
-
-        fileptr.close();
+    if (info->depends(false).size()) {
+        fileptr << "depends:"
+                << "\n";
+        for (auto const &i : info->depends(false))
+            fileptr << " - " << i << "\n";
+    }
 
-        std::string command = _archive_tool;
+    fileptr.close();
 
-        command += " --zstd -cf " + _pkgfile + " -C " + srcdir + " . ";
-        if (exec().execute(command) != 0)
-        {
-            _error = "failed to execute command for compression '" + command + "'";
-            return false;
-        }
+    std::string command = _archive_tool;
 
-        return true;
+    command += " --zstd -cf " + _pkgfile + " -C " + srcdir + " . ";
+    if (exec().execute(command) != 0) {
+        _error = "failed to execute command for compression '" + command + "'";
+        return false;
     }
 
-    bool archive::extract(std::string const &outdir)
-    {
-        if (!std::filesystem::exists(_pkgfile))
-        {
-            _error = "no " + _pkgfile + " exist";
-            return false;
-        }
+    return true;
+}
 
-        std::string cmd = _archive_tool;
+bool archive::extract(std::string const &outdir) {
+    if (!std::filesystem::exists(_pkgfile)) {
+        _error = "no " + _pkgfile + " exist";
+        return false;
+    }
 
-        cmd += " --zstd --exclude './info' -xhpf " + _pkgfile + " -C " + outdir;
-        if (exec().execute(cmd) != 0)
-        {
-            _error = "failed to execute extraction command";
-            return false;
-        }
+    std::string cmd = _archive_tool;
 
-        return true;
+    cmd += " --zstd --exclude './info' -xhpf " + _pkgfile + " -C " + outdir;
+    if (exec().execute(cmd) != 0) {
+        _error = "failed to execute extraction command";
+        return false;
     }
-}
\ No newline at end of file
+
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/archive.hh b/libpkgupd/archive.hh
index 7b78e00..fcde145 100644
--- a/libpkgupd/archive.hh
+++ b/libpkgupd/archive.hh
@@ -1,68 +1,65 @@
 #ifndef _PKGUPD_EXTRACTOR_HH_
 #define _PKGUPD_EXTRACTOR_HH_
 
+#include <yaml-cpp/yaml.h>
+
 #include "defines.hh"
 #include "pkginfo.hh"
-#include <yaml-cpp/yaml.h>
 
-namespace rlxos::libpkgupd
-{
-    /**
+namespace rlxos::libpkgupd {
+/**
      * This class represent rlxos compressed package,
      * @brief It provides various methods to handle, read, compress and extract rlxos packages
      */
-    class archive : public object
-    {
-    public:
-        class package : public pkginfo
-        {
-        private:
-            std::string _id, _version,
-                _about;
-            
-            std::vector<std::string> _depends;
+class archive : public object {
+   public:
+    class package : public pkginfo {
+       private:
+        std::string _id, _version,
+            _about;
 
-        public:
-            package(YAML::Node const &data, std::string const &file);
+        std::vector<std::string> _depends;
 
-            std::string id() const { return _id; }
-            std::string version() const { return _version; }
-            std::string about() const { return _about; }
-            std::vector<std::string> depends(bool) const { return _depends; }
-        };
+       public:
+        package(YAML::Node const &data, std::string const &file);
 
-    private:
-        std::string _pkgfile;
-        std::string _archive_tool;
-        std::shared_ptr<archive::package> _package;
+        std::string id() const { return _id; }
+        std::string version() const { return _version; }
+        std::string about() const { return _about; }
+        std::vector<std::string> depends(bool) const { return _depends; }
+    };
 
-    public:
-        archive(std::string const &packagefile,
-                std::string const &archivetool = DEFAULT_ARCHIVE_TOOL)
-            : _pkgfile{packagefile},
-              _archive_tool{archivetool}
-        {
-        }
+   private:
+    std::string _pkgfile;
+    std::string _archive_tool;
+    std::shared_ptr<archive::package> _package;
 
-        /**
+   public:
+    archive(std::string const &packagefile,
+            std::string const &archivetool = DEFAULT_ARCHIVE_TOOL)
+        : _pkgfile{packagefile},
+          _archive_tool{archivetool} {
+    }
+
+    /**
          * @brief Provides the file data of specified file in the package
          * @param filepath path to the file in package (must be started from ./)
          * @return content of file
          */
-        std::tuple<int, std::string> getdata(std::string const &filepath);
+    std::tuple<int, std::string> getdata(std::string const &filepath);
 
-        std::shared_ptr<archive::package> info();
-        /**
+    std::shared_ptr<archive::package> info();
+    /**
          * List all files in the archive
          */
-        std::vector<std::string> list();
+    std::vector<std::string> list();
 
-        bool is_exist(std::string const &path) const;
+    bool is_exist(std::string const &path) const;
 
-        bool extract(std::string const &outdir);
+    bool extract(std::string const &outdir);
 
-        bool compress(std::string const &srcdir, std::shared_ptr<pkginfo> const &info);
-    };
-}
+    bool compress(std::string const &srcdir, std::shared_ptr<pkginfo> const &info);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/builder.cc b/libpkgupd/builder.cc
index 97d19ec..de2330f 100644
--- a/libpkgupd/builder.cc
+++ b/libpkgupd/builder.cc
@@ -1,210 +1,176 @@
 #include "builder.hh"
-#include "downloader.hh"
-#include "stripper.hh"
-#include "exec.hh"
+
+#include <iostream>
+
 #include "archive.hh"
 #include "compiler.hh"
+#include "downloader.hh"
+#include "exec.hh"
+#include "stripper.hh"
 
-#include <iostream>
+namespace rlxos::libpkgupd {
 
-namespace rlxos::libpkgupd
-{
-
-    bool builder::_prepare(std::vector<std::string> const &sources, std::string const &srcdir)
-    {
-        for (auto const &i : sources)
-        {
-            std::string pkgfile = std::filesystem::path(i).filename().string();
-            std::string url = i;
-
-            size_t idx = i.rfind("::");
-            if (idx != std::string::npos)
-            {
-                pkgfile = i.substr(0, idx);
-                url = i.substr(idx + 2, i.length() - (idx + 2));
-            }
+bool builder::_prepare(std::vector<std::string> const &sources, std::string const &srcdir) {
+    for (auto const &i : sources) {
+        std::string pkgfile = std::filesystem::path(i).filename().string();
+        std::string url = i;
 
-            std::string outfile = _src_dir + "/" + pkgfile;
+        size_t idx = i.rfind("::");
+        if (idx != std::string::npos) {
+            pkgfile = i.substr(0, idx);
+            url = i.substr(idx + 2, i.length() - (idx + 2));
+        }
 
-            auto downloader_ = downloader();
+        std::string outfile = _src_dir + "/" + pkgfile;
 
-            if (!std::filesystem::exists(outfile))
-            {
-                if (!downloader_.download(url, outfile))
-                {
-                    _error = downloader_.error();
-                    return false;
-                }
-            }
+        auto downloader_ = downloader();
 
-            auto endswith = [](std::string const &fullstr, std::string const &ending)
-            {
-                if (fullstr.length() >= ending.length())
-                    return (0 == fullstr.compare(fullstr.length() - ending.length(), ending.length(), ending));
-                else
-                    return false;
-            };
-
-            bool extracted = false;
-
-            for (auto const &i : {".tar", ".gz", ".tgz", ".xz", ".txz", ".bzip2", ".bz", ".bz2", ".lzma"})
-            {
-                if (endswith(outfile, i))
-                {
-                    if (int status = exec().execute("tar -xaf " + outfile + " -C " + srcdir); status != 0)
-                    {
-                        _error = "failed to extract " + outfile + " with tar, exit status: " + std::to_string(status);
-                        return false;
-                    }
-                    extracted = true;
-                    break;
-                }
+        if (!std::filesystem::exists(outfile)) {
+            if (!downloader_.download(url, outfile)) {
+                _error = downloader_.error();
+                return false;
             }
+        }
 
-            if (endswith(outfile, "zip"))
-            {
-                if (int status = exec().execute("unzip " + outfile + " -d " + srcdir); status != 0)
-                {
-                    _error = "failed to extract " + outfile + " with unzip, exit status:  " + std::to_string(status);
-                    return false;
-                }
-                extracted = true;
-            }
+        auto endswith = [](std::string const &fullstr, std::string const &ending) {
+            if (fullstr.length() >= ending.length())
+                return (0 == fullstr.compare(fullstr.length() - ending.length(), ending.length(), ending));
+            else
+                return false;
+        };
 
-            if (!extracted)
-            {
-                std::error_code err;
-                std::filesystem::copy(outfile, srcdir + "/" + std::filesystem::path(outfile).filename().string(), err);
-                if (err)
-                {
-                    _error = err.message();
+        bool extracted = false;
+
+        for (auto const &i : {".tar", ".gz", ".tgz", ".xz", ".txz", ".bzip2", ".bz", ".bz2", ".lzma"}) {
+            if (endswith(outfile, i)) {
+                if (int status = exec().execute("tar -xaf " + outfile + " -C " + srcdir); status != 0) {
+                    _error = "failed to extract " + outfile + " with tar, exit status: " + std::to_string(status);
                     return false;
                 }
+                extracted = true;
+                break;
             }
         }
 
-        return true;
-    }
-
-    bool builder::_compile(std::string const &srcdir, std::string const &destdir, std::shared_ptr<recipe::package> package)
-    {
-        auto compiler_ = compiler(package);
-        if (!compiler_.compile(srcdir, destdir))
-        {
-            _error = compiler_.error();
-            return false;
-        }
-
-        return true;
-    }
-
-    bool builder::_build(std::shared_ptr<recipe::package> package)
-    {
-        std::string pkg_work_dir = _work_dir + "/" + package->id();
-        std::string pkg_src_dir = pkg_work_dir + "/src";
-        std::string pkg_pkg_dir = pkg_work_dir + "/pkg";
-
-        std::string pkgfile = _pkgs_dir + "/" + package->packagefile(package->pack());
-        if (std::filesystem::exists(pkgfile) && !_force)
-        {
-            std::cout << "Found in cache, skipping" << std::endl;
-            if (package->pack() != "none")
-            {
-                _archive_list.push_back(pkgfile);
+        if (endswith(outfile, "zip")) {
+            if (int status = exec().execute("unzip " + outfile + " -d " + srcdir); status != 0) {
+                _error = "failed to extract " + outfile + " with unzip, exit status:  " + std::to_string(status);
+                return false;
             }
-            return true;
+            extracted = true;
         }
 
-        for (auto const &dir : {pkg_src_dir})
-        {
+        if (!extracted) {
             std::error_code err;
-            std::filesystem::create_directories(dir, err);
-            if (err)
-            {
+            std::filesystem::copy(outfile, srcdir + "/" + std::filesystem::path(outfile).filename().string(), err);
+            if (err) {
                 _error = err.message();
                 return false;
             }
         }
+    }
 
-        auto allSources = package->sources();
+    return true;
+}
 
-        if (!_prepare(allSources, pkg_src_dir))
-        {
-            return false;
+bool builder::_compile(std::string const &srcdir, std::string const &destdir, std::shared_ptr<recipe::package> package) {
+    auto compiler_ = compiler(package);
+    if (!compiler_.compile(srcdir, destdir)) {
+        _error = compiler_.error();
+        return false;
+    }
+
+    return true;
+}
+
+bool builder::_build(std::shared_ptr<recipe::package> package) {
+    std::string pkg_work_dir = _work_dir + "/" + package->id();
+    std::string pkg_src_dir = pkg_work_dir + "/src";
+    std::string pkg_pkg_dir = pkg_work_dir + "/pkg";
+
+    std::string pkgfile = _pkgs_dir + "/" + package->packagefile(package->pack());
+    if (std::filesystem::exists(pkgfile) && !_force) {
+        std::cout << "Found in cache, skipping" << std::endl;
+        if (package->pack() != "none") {
+            _archive_list.push_back(pkgfile);
         }
+        return true;
+    }
 
-        // Inserting required environment variables
-        package->prepand_environ("PKGUPD_SRCDIR=" + _src_dir);
-        package->prepand_environ("PKGUPD_PKGDIR=" + _pkgs_dir);
-        package->prepand_environ("pkgupd_srcdir=" + pkg_src_dir);
-        package->prepand_environ("pkgupd_pkgdir=" + pkg_pkg_dir);
-
-        if (package->prescript().size())
-        {
-            if (int status = exec().execute(package->prescript(), pkg_src_dir + "/" + package->dir(), package->environ()); status != 0)
-            {
-                _error = "prescript failed to exit code: " + std::to_string(status);
-                return false;
-            }
+    for (auto const &dir : {pkg_src_dir}) {
+        std::error_code err;
+        std::filesystem::create_directories(dir, err);
+        if (err) {
+            _error = err.message();
+            return false;
         }
+    }
+
+    auto allSources = package->sources();
 
-        PROCESS("compiling source code")
+    if (!_prepare(allSources, pkg_src_dir)) {
+        return false;
+    }
 
-        if (!_compile(pkg_src_dir + "/" + package->dir(), pkg_pkg_dir, package))
-        {
+    // Inserting required environment variables
+    package->prepand_environ("PKGUPD_SRCDIR=" + _src_dir);
+    package->prepand_environ("PKGUPD_PKGDIR=" + _pkgs_dir);
+    package->prepand_environ("pkgupd_srcdir=" + pkg_src_dir);
+    package->prepand_environ("pkgupd_pkgdir=" + pkg_pkg_dir);
+
+    if (package->prescript().size()) {
+        if (int status = exec().execute(package->prescript(), pkg_src_dir + "/" + package->dir(), package->environ()); status != 0) {
+            _error = "prescript failed to exit code: " + std::to_string(status);
             return false;
         }
+    }
 
-        if (package->postscript().size())
-        {
-            if (int status = exec().execute(package->postscript(), pkg_src_dir + "/" + package->dir(), package->environ()); status != 0)
-            {
-                _error = "postscript failed to exit code: " + std::to_string(status);
-                return false;
-            }
-        }
+    PROCESS("compiling source code")
 
-        for (auto const &i : std::filesystem::recursive_directory_iterator(pkg_pkg_dir))
-        {
-            if (i.is_regular_file() && i.path().filename().extension() == ".la")
-            {
-                DEBUG("removing " + i.path().string());
-                std::filesystem::remove(i);
-            }
-        }
+    if (!_compile(pkg_src_dir + "/" + package->dir(), pkg_pkg_dir, package)) {
+        return false;
+    }
 
-        if (package->strip())
-        {
-            stripper stripper_(package->skipstrip());
+    if (package->postscript().size()) {
+        if (int status = exec().execute(package->postscript(), pkg_src_dir + "/" + package->dir(), package->environ()); status != 0) {
+            _error = "postscript failed to exit code: " + std::to_string(status);
+            return false;
+        }
+    }
 
-            PROCESS("stripping " + package->id());
-            if (!stripper_.strip(pkg_pkg_dir))
-            {
-                _error = stripper_.error();
-                return false;
-            }
+    for (auto const &i : std::filesystem::recursive_directory_iterator(pkg_pkg_dir)) {
+        if (i.is_regular_file() && i.path().filename().extension() == ".la") {
+            DEBUG("removing " + i.path().string());
+            std::filesystem::remove(i);
         }
+    }
+
+    if (package->strip()) {
+        stripper stripper_(package->skipstrip());
 
-        if (package->pack() == "none")
-        {
-            INFO("No packaging done");
+        PROCESS("stripping " + package->id());
+        if (!stripper_.strip(pkg_pkg_dir)) {
+            _error = stripper_.error();
+            return false;
         }
-        else
-        {
-            PROCESS("packaging rlx archive");
-
-            auto archive_ = archive(pkgfile);
-            if (!archive_.compress(pkg_pkg_dir, package))
-            {
-                _error = archive_.error();
-                return false;
-            }
+    }
 
-            INFO("Package generated at " + pkgfile)
+    if (package->pack() == "none") {
+        INFO("No packaging done");
+    } else {
+        PROCESS("packaging rlx archive");
 
-            _archive_list.push_back(pkgfile);
+        auto archive_ = archive(pkgfile);
+        if (!archive_.compress(pkg_pkg_dir, package)) {
+            _error = archive_.error();
+            return false;
         }
 
-        return true;
+        INFO("Package generated at " + pkgfile)
+
+        _archive_list.push_back(pkgfile);
     }
-}
\ No newline at end of file
+
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/builder.hh b/libpkgupd/builder.hh
index 5594849..3d9ac24 100644
--- a/libpkgupd/builder.hh
+++ b/libpkgupd/builder.hh
@@ -3,70 +3,62 @@
 
 #include "recipe.hh"
 
-namespace rlxos::libpkgupd
-{
-    class builder : public object
-    {
-    private:
-        std::vector<std::shared_ptr<recipe::package>> _packages;
-        std::vector<std::string> _archive_list;
+namespace rlxos::libpkgupd {
+class builder : public object {
+   private:
+    std::vector<std::shared_ptr<recipe::package>> _packages;
+    std::vector<std::string> _archive_list;
 
-        std::string _work_dir,
-            _pkgs_dir,
-            _src_dir;
+    std::string _work_dir,
+        _pkgs_dir,
+        _src_dir;
 
-        bool _force = false;
+    bool _force = false;
 
-        bool _prepare(std::vector<std::string> const &sources, std::string const &srcdir);
+    bool _prepare(std::vector<std::string> const &sources, std::string const &srcdir);
 
-        bool _compile(std::string const &srcdir, std::string const &pkgdir, std::shared_ptr<recipe::package> package);
+    bool _compile(std::string const &srcdir, std::string const &pkgdir, std::shared_ptr<recipe::package> package);
 
-        bool _build(std::shared_ptr<recipe::package> package);
+    bool _build(std::shared_ptr<recipe::package> package);
 
-    public:
-        builder(std::string const &wdir,
-                std::string const &pdir,
-                std::string const &sdir,
-                bool force)
-            : _work_dir{wdir},
-              _pkgs_dir{pdir},
-              _src_dir{sdir},
-              _force{force} {}
+   public:
+    builder(std::string const &wdir,
+            std::string const &pdir,
+            std::string const &sdir,
+            bool force)
+        : _work_dir{wdir},
+          _pkgs_dir{pdir},
+          _src_dir{sdir},
+          _force{force} {}
 
-        ~builder()
-        {
-            std::filesystem::remove_all(_work_dir);
-        }
+    ~builder() {
+        std::filesystem::remove_all(_work_dir);
+    }
 
-        GET_METHOD(std::vector<std::string>, archive_list);
+    GET_METHOD(std::vector<std::string>, archive_list);
 
-        bool build(std::shared_ptr<recipe> const &recipe_)
-        {
-            _work_dir += "/" + recipe_->id();
+    bool build(std::shared_ptr<recipe> const &recipe_) {
+        _work_dir += "/" + recipe_->id();
 
-            for (auto const &dir : {_pkgs_dir, _src_dir, _work_dir})
-            {
-                if (!std::filesystem::exists(dir))
-                {
-                    std::error_code err;
-                    std::filesystem::create_directories(dir, err);
-                    if (err)
-                    {
-                        _error = err.message();
-                        return false;
-                    }
-                }
-            }
-            for (auto const &pkg : recipe_->packages())
-                if (!_build(pkg))
-                {
-                    std::filesystem::remove_all(_work_dir);
+        for (auto const &dir : {_pkgs_dir, _src_dir, _work_dir}) {
+            if (!std::filesystem::exists(dir)) {
+                std::error_code err;
+                std::filesystem::create_directories(dir, err);
+                if (err) {
+                    _error = err.message();
                     return false;
                 }
-
-            return true;
+            }
         }
-    };
-}
+        for (auto const &pkg : recipe_->packages())
+            if (!_build(pkg)) {
+                std::filesystem::remove_all(_work_dir);
+                return false;
+            }
+
+        return true;
+    }
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/compiler.cc b/libpkgupd/compiler.cc
index 4d99e2c..5e30e01 100644
--- a/libpkgupd/compiler.cc
+++ b/libpkgupd/compiler.cc
@@ -1,102 +1,87 @@
 #include "compiler.hh"
+
 #include "exec.hh"
 
-namespace rlxos::libpkgupd
-{
-    compiler::configurator compiler::_detect_configurator(std::string const &path)
-    {
-        std::string touse;
-
-        for (auto const &i : _package->flags())
-        {
-            if (i->id() == "configurator")
-            {
-                touse = i->value();
-                break;
-            }
-        }
+namespace rlxos::libpkgupd {
+compiler::configurator compiler::_detect_configurator(std::string const &path) {
+    std::string touse;
 
-        if (touse.size())
-        {
-            if (_configurators.find(touse) == _configurators.end())
-                return configurator::INVALID;
-            else
-                return _configurators[touse];
+    for (auto const &i : _package->flags()) {
+        if (i->id() == "configurator") {
+            touse = i->value();
+            break;
         }
+    }
 
-        for (auto const &i : _configurators)
-            if (std::filesystem::exists(path + "/" + i.first))
-                return i.second;
-
-        return configurator::INVALID;
+    if (touse.size()) {
+        if (_configurators.find(touse) == _configurators.end())
+            return configurator::INVALID;
+        else
+            return _configurators[touse];
     }
 
-    compiler::builder compiler::_detect_builder(std::string const &path)
-    {
-        std::string touse;
+    for (auto const &i : _configurators)
+        if (std::filesystem::exists(path + "/" + i.first))
+            return i.second;
 
-        for (auto const &i : _package->flags())
-        {
-            if (i->id() == "builder")
-            {
-                touse = i->value();
-                break;
-            }
-        }
+    return configurator::INVALID;
+}
 
-        if (touse.size())
-        {
-            if (_builders.find(touse) == _builders.end())
-                return builder::INVALID;
-            else
-                return _builders[touse];
-        }
+compiler::builder compiler::_detect_builder(std::string const &path) {
+    std::string touse;
 
-        for (auto const &i : _builders)
-            if (std::filesystem::exists(path + "/" + i.first))
-                return i.second;
+    for (auto const &i : _package->flags()) {
+        if (i->id() == "builder") {
+            touse = i->value();
+            break;
+        }
+    }
 
-        return builder::INVALID;
+    if (touse.size()) {
+        if (_builders.find(touse) == _builders.end())
+            return builder::INVALID;
+        else
+            return _builders[touse];
     }
 
-    bool compiler::compile(std::string const &srcdir, std::string const &destdir)
-    {
-        std::string builddir = srcdir;
+    for (auto const &i : _builders)
+        if (std::filesystem::exists(path + "/" + i.first))
+            return i.second;
 
-        if (_package->script().size() != 0)
-        {
-            if (int status = exec().execute(_package->script(), srcdir, _package->environ()); status != 0)
-            {
-                _error = "script failed with exit code: " + std::to_string(status);
-                return false;
-            }
+    return builder::INVALID;
+}
 
-            return true;
+bool compiler::compile(std::string const &srcdir, std::string const &destdir) {
+    std::string builddir = srcdir;
+
+    if (_package->script().size() != 0) {
+        if (int status = exec().execute(_package->script(), srcdir, _package->environ()); status != 0) {
+            _error = "script failed with exit code: " + std::to_string(status);
+            return false;
         }
 
-        auto getargs = [&](std::string const &var, std::string fallback)
-        {
-            for (auto const &i : this->_package->flags())
-            {
-                if (i->id() == var)
-                {
-                    if (i->force())
-                        return i->value();
-                    return fallback + " " + i->value();
-                }
+        return true;
+    }
+
+    auto getargs = [&](std::string const &var, std::string fallback) {
+        for (auto const &i : this->_package->flags()) {
+            if (i->id() == var) {
+                if (i->force())
+                    return i->value();
+                return fallback + " " + i->value();
             }
-            return fallback;
-        };
+        }
+        return fallback;
+    };
 
-        auto config = _detect_configurator(srcdir);
+    auto config = _detect_configurator(srcdir);
 
-        builddir = srcdir + "/pkgupd_build_" + _package->id();
-        std::filesystem::create_directories(builddir);
+    builddir = srcdir + "/pkgupd_build_" + _package->id();
+    std::filesystem::create_directories(builddir);
 
-        std::string cmd;
+    std::string cmd;
 
-        switch (config)
-        {
+    switch (config) {
         case configurator::AUTOCONF:
             cmd = srcdir + "/configure " + getargs("configure", "--prefix=/usr");
             break;
@@ -113,17 +98,15 @@ namespace rlxos::libpkgupd
         default:
             _error = "no known configurator found";
             return false;
-        }
+    }
 
-        if (int status = exec().execute(cmd, builddir, _package->environ()); status != 0)
-        {
-            _error = "failed to configure, exit code: " + std::to_string(status);
-            return false;
-        }
+    if (int status = exec().execute(cmd, builddir, _package->environ()); status != 0) {
+        _error = "failed to configure, exit code: " + std::to_string(status);
+        return false;
+    }
 
-        auto builder = _detect_builder(builddir);
-        switch (builder)
-        {
+    auto builder = _detect_builder(builddir);
+    switch (builder) {
         case builder::MAKE:
             cmd = "make " + getargs("compile", "");
             break;
@@ -134,24 +117,22 @@ namespace rlxos::libpkgupd
         default:
             _error = "No known configurator found";
             return false;
-        }
+    }
 
-        if (int status = exec().execute(cmd, builddir, _package->environ()); status != 0)
-        {
-            _error = "Failed to compile, exit code: " + std::to_string(status);
-            return false;
-        }
+    if (int status = exec().execute(cmd, builddir, _package->environ()); status != 0) {
+        _error = "Failed to compile, exit code: " + std::to_string(status);
+        return false;
+    }
 
-        std::vector<std::string> environ = _package->environ();
+    std::vector<std::string> environ = _package->environ();
 
-        std::string DESTDIR = "DESTDIR=" + destdir;
-        if (_package->pack() == "none")
-            DESTDIR = "";
-        else
-            environ.push_back(DESTDIR);
+    std::string DESTDIR = "DESTDIR=" + destdir;
+    if (_package->pack() == "none")
+        DESTDIR = "";
+    else
+        environ.push_back(DESTDIR);
 
-        switch (builder)
-        {
+    switch (builder) {
         case builder::MAKE:
             cmd = "make " + getargs("install", DESTDIR + " install");
             break;
@@ -162,14 +143,13 @@ namespace rlxos::libpkgupd
         default:
             _error = "No known configurator found";
             return false;
-        }
-
-        if (int status = exec().execute(cmd, builddir, environ); status != 0)
-        {
-            _error = "failed to compile, exit code: " + std::to_string(status);
-            return false;
-        }
+    }
 
-        return true;
+    if (int status = exec().execute(cmd, builddir, environ); status != 0) {
+        _error = "failed to compile, exit code: " + std::to_string(status);
+        return false;
     }
-}
\ No newline at end of file
+
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/compiler.hh b/libpkgupd/compiler.hh
index 26e7a85..70ac42a 100644
--- a/libpkgupd/compiler.hh
+++ b/libpkgupd/compiler.hh
@@ -1,61 +1,57 @@
 #ifndef _LIBPKGUPD_COMPILER_HH_
 #define _LIBPKGUPD_COMPILER_HH_
 
-#include <tuple>
-#include <string>
 #include <map>
+#include <string>
+#include <tuple>
 
 #include "defines.hh"
 #include "recipe.hh"
 
-namespace rlxos::libpkgupd
-{
-    class compiler : public object
-    {
-    private:
-        std::shared_ptr<recipe::package> _package;
+namespace rlxos::libpkgupd {
+class compiler : public object {
+   private:
+    std::shared_ptr<recipe::package> _package;
+
+    enum class configurator {
+        INVALID,
+        AUTOCONF,
+        AUTOGEN,
+        PYSETUP,
+        MESON,
+        CMAKE
+    };
+    enum class builder {
+        INVALID,
+        NINJA,
+        MAKE,
+    };
 
-        enum class configurator
+    std::map<std::string, configurator> _configurators =
         {
-            INVALID,
-            AUTOCONF,
-            AUTOGEN,
-            PYSETUP,
-            MESON,
-            CMAKE
+            {"configure", configurator::AUTOCONF},
+            {"autogen.sh", configurator::AUTOGEN},
+            {"CMakeLists.txt", configurator::CMAKE},
+            {"meson.build", configurator::MESON},
+            {"setup.py", configurator::PYSETUP},
         };
-        enum class builder
+
+    std::map<std::string, builder> _builders =
         {
-            INVALID,
-            NINJA,
-            MAKE,
+            {"Makefile", builder::MAKE},
+            {"build.ninja", builder::NINJA},
         };
 
-        std::map<std::string, configurator> _configurators =
-            {
-                {"configure", configurator::AUTOCONF},
-                {"autogen.sh", configurator::AUTOGEN},
-                {"CMakeLists.txt", configurator::CMAKE},
-                {"meson.build", configurator::MESON},
-                {"setup.py", configurator::PYSETUP},
-            };
-
-        std::map<std::string, builder> _builders =
-            {
-                {"Makefile", builder::MAKE},
-                {"build.ninja", builder::NINJA},
-            };
+    configurator _detect_configurator(std::string const &path);
 
-        configurator _detect_configurator(std::string const &path);
+    builder _detect_builder(std::string const &path);
 
-        builder _detect_builder(std::string const &path);
+   public:
+    compiler(std::shared_ptr<recipe::package> &package)
+        : _package{package} {}
 
-    public:
-        compiler(std::shared_ptr<recipe::package> &package)
-            : _package{package} {}
-
-        bool compile(std::string const &srcdir, std::string const &pkgdir);
-    };
-}
+    bool compile(std::string const &srcdir, std::string const &pkgdir);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/db.hh b/libpkgupd/db.hh
index 96a2940..95f21de 100644
--- a/libpkgupd/db.hh
+++ b/libpkgupd/db.hh
@@ -4,23 +4,20 @@
 #include "defines.hh"
 #include "pkginfo.hh"
 
-namespace rlxos::libpkgupd
-{
-    class db : public object
-    {
-    protected:
-        std::string _data_dir;
+namespace rlxos::libpkgupd {
+class db : public object {
+   protected:
+    std::string _data_dir;
 
-    public:
-        db(std::string const &datadir)
-            : _data_dir{datadir}
-        {
-        }
+   public:
+    db(std::string const &datadir)
+        : _data_dir{datadir} {
+    }
 
-        GET_METHOD(std::string, data_dir);
+    GET_METHOD(std::string, data_dir);
 
-        virtual std::shared_ptr<pkginfo> operator[](std::string const &pkgid) = 0;
-    };
-}
+    virtual std::shared_ptr<pkginfo> operator[](std::string const &pkgid) = 0;
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/defines.hh b/libpkgupd/defines.hh
index cba409f..ba17692 100644
--- a/libpkgupd/defines.hh
+++ b/libpkgupd/defines.hh
@@ -1,40 +1,36 @@
 #ifndef _LIBPKGUPD_DEFINES_HH_
 #define _LIBPKGUPD_DEFINES_HH_
 
-#include <string>
-#include <vector>
-#include <memory>
 #include <assert.h>
-#include <stdexcept>
+
 #include <filesystem>
+#include <memory>
+#include <stdexcept>
+#include <string>
+#include <vector>
 
 #include "colors.hh"
 
-namespace rlxos::libpkgupd
-{
-    class object
-    {
-    protected:
-        std::string _error;
+namespace rlxos::libpkgupd {
+class object {
+   protected:
+    std::string _error;
 
-    public:
-        std::string const &error() const
-        {
-            return _error;
-        }
-    };
+   public:
+    std::string const &error() const {
+        return _error;
+    }
+};
 
-}
+}  // namespace rlxos::libpkgupd
 
 #define GET_METHOD(type, var) \
-    type const &var() const   \
-    {                         \
+    type const &var() const { \
         return _##var;        \
     }
 
 #define SET_METHOD(type, val) \
-    void val(type val)        \
-    {                         \
+    void val(type val) {      \
         _##val = val;         \
     }
 
diff --git a/libpkgupd/downloader.cc b/libpkgupd/downloader.cc
index cc1cef5..6d71978 100644
--- a/libpkgupd/downloader.cc
+++ b/libpkgupd/downloader.cc
@@ -1,161 +1,146 @@
 #include "downloader.hh"
-#include <iostream>
-#include <curl/curl.h>
 
+#include <curl/curl.h>
 #include <math.h>
 
-namespace rlxos::libpkgupd
-{
-
-    int progress_func(void *ptr, double TotalToDownload, double NowDownloaded,
-                      double TotalToUpload, double NowUploaded)
-    {
-        // ensure that the file to be downloaded is not empty
-        // because that would cause a division by zero error later on
-        if (TotalToDownload <= 0.0)
-        {
-            return 0;
-        }
+#include <iostream>
 
-        // how wide you want the progress meter to be
-        int totaldotz = 40;
-        double fractiondownloaded = NowDownloaded / TotalToDownload;
-        // part of the progressmeter that's already "full"
-        int dotz = (int)round(fractiondownloaded * totaldotz);
-
-        // create the "meter"
-        int ii = 0;
-        printf("%3.0f%% \033[1m[\033[0m", fractiondownloaded * 100);
-        // part  that's full already
-        for (; ii < dotz; ii++)
-        {
-            printf("\033[32;1m■\033[0m");
-        }
-        // remaining part (spaces)
-        for (; ii < totaldotz; ii++)
-        {
-            printf("\033[1m \033[0m");
-        }
-        // and back to line begin - do not forget the fflush to avoid output buffering problems!
-        printf("\033[1m]\033[0m\r");
-        fflush(stdout);
-        // if you don't return 0, the transfer will be aborted - see the documentation
+namespace rlxos::libpkgupd {
+
+int progress_func(void *ptr, double TotalToDownload, double NowDownloaded,
+                  double TotalToUpload, double NowUploaded) {
+    // ensure that the file to be downloaded is not empty
+    // because that would cause a division by zero error later on
+    if (TotalToDownload <= 0.0) {
         return 0;
     }
 
-    bool downloader::download(std::string const &url, std::string const &outfile)
-    {
-        CURL *curl;
-        CURLcode res;
-        FILE *fptr;
+    // how wide you want the progress meter to be
+    int totaldotz = 40;
+    double fractiondownloaded = NowDownloaded / TotalToDownload;
+    // part of the progressmeter that's already "full"
+    int dotz = (int)round(fractiondownloaded * totaldotz);
+
+    // create the "meter"
+    int ii = 0;
+    printf("%3.0f%% \033[1m[\033[0m", fractiondownloaded * 100);
+    // part  that's full already
+    for (; ii < dotz; ii++) {
+        printf("\033[32;1m■\033[0m");
+    }
+    // remaining part (spaces)
+    for (; ii < totaldotz; ii++) {
+        printf("\033[1m \033[0m");
+    }
+    // and back to line begin - do not forget the fflush to avoid output buffering problems!
+    printf("\033[1m]\033[0m\r");
+    fflush(stdout);
+    // if you don't return 0, the transfer will be aborted - see the documentation
+    return 0;
+}
+
+bool downloader::download(std::string const &url, std::string const &outfile) {
+    CURL *curl;
+    CURLcode res;
+    FILE *fptr;
+
+    PROCESS("download " << url);
+
+    curl = curl_easy_init();
+    if (!curl) {
+        _error = "Failed to initialize curl";
+        return false;
+    }
 
-        PROCESS("download " << url);
+    fptr = fopen((outfile + ".part").c_str(), "wb");
+    if (!fptr) {
+        _error = "Failed to open " + outfile + " for write";
+        return false;
+    }
 
-        curl = curl_easy_init();
-        if (!curl)
-        {
-            _error = "Failed to initialize curl";
-            return false;
-        }
+    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
+    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, fwrite);
+    curl_easy_setopt(curl, CURLOPT_WRITEDATA, fptr);
+    curl_easy_setopt(curl, CURLOPT_VERBOSE, (getenv("CURL_DEBUG") == nullptr ? 0L : 1L));
+    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+    if (getenv("PKGUPD_NO_PROGRESS") == nullptr) {
+        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, false);
+        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_func);
+    }
+    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000);
+    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10);
 
-        fptr = fopen((outfile + ".part").c_str(), "wb");
-        if (!fptr)
-        {
-            _error = "Failed to open " + outfile + " for write";
-            return false;
-        }
+    res = curl_easy_perform(curl);
 
-        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
-        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, fwrite);
-        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fptr);
-        curl_easy_setopt(curl, CURLOPT_VERBOSE, (getenv("CURL_DEBUG") == nullptr ? 0L : 1L));
-        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
-        if (getenv("PKGUPD_NO_PROGRESS") == nullptr)
-        {
-            curl_easy_setopt(curl, CURLOPT_NOPROGRESS, false);
-            curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progress_func);
-        }
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000);
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10);
+    std::cout << std::endl;
 
-        res = curl_easy_perform(curl);
+    curl_easy_cleanup(curl);
+    fclose(fptr);
 
-        std::cout << std::endl;
+    if (res == CURLE_OK) {
+        std::error_code err;
 
-        curl_easy_cleanup(curl);
-        fclose(fptr);
+        std::filesystem::rename(outfile + ".part", outfile, err);
+        if (err) {
+            _error = err.message();
+            return false;
+        }
+    }
 
-        if (res == CURLE_OK)
-        {
-            std::error_code err;
+    return res == CURLE_OK;
+}
 
-            std::filesystem::rename(outfile + ".part", outfile, err);
-            if (err)
-            {
-                _error = err.message();
-                return false;
-            }
-        }
+bool downloader::valid(std::string const &url) {
+    CURL *curl;
+    CURLcode resp;
 
-        return res == CURLE_OK;
+    curl = curl_easy_init();
+    if (!curl) {
+        _error = "failed to initialize curl";
+        return false;
     }
 
-    bool downloader::valid(std::string const &url)
-    {
-        CURL *curl;
-        CURLcode resp;
+    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
+    curl_easy_setopt(curl, CURLOPT_NOBODY, 1);
+    curl_easy_setopt(curl, CURLOPT_VERBOSE, (getenv("CURL_DEBUG") == nullptr ? 0L : 1L));
+    curl_easy_setopt(curl, CURLOPT_FAILONERROR, true);
+    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
+    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000);
+    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10);
 
-        curl = curl_easy_init();
-        if (!curl)
-        {
-            _error = "failed to initialize curl";
-            return false;
-        }
+    resp = curl_easy_perform(curl);
 
-        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
-        curl_easy_setopt(curl, CURLOPT_NOBODY, 1);
-        curl_easy_setopt(curl, CURLOPT_VERBOSE, (getenv("CURL_DEBUG") == nullptr ? 0L : 1L));
-        curl_easy_setopt(curl, CURLOPT_FAILONERROR, true);
-        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 1000);
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10);
+    long http_code = 0;
+    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
 
-        resp = curl_easy_perform(curl);
+    curl_easy_cleanup(curl);
+    if ((resp == CURLE_OK) && http_code == 200)
+        return true;
 
-        long http_code = 0;
-        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &http_code);
+    _error = "invalid url " + url;
+    return false;
+}
 
-        curl_easy_cleanup(curl);
-        if ((resp == CURLE_OK) && http_code == 200)
-            return true;
-
-        _error = "invalid url " + url;
+bool downloader::get(std::string const &file, std::string const &outdir) {
+    if (_urls.size() == 0) {
+        _error = "No url specified";
         return false;
     }
 
-    bool downloader::get(std::string const &file, std::string const &outdir)
-    {
-        if (_urls.size() == 0)
-        {
-            _error = "No url specified";
-            return false;
-        }
-
-        for (auto const &url : _urls)
-        {
-            PROCESS("checking " << url << " " << file);
+    for (auto const &url : _urls) {
+        PROCESS("checking " << url << " " << file);
 
-            std::string fileurl = url + "/" + file;
+        std::string fileurl = url + "/" + file;
 
-            if (!getenv("NO_CURL_CHECK"))
-                if (!valid(fileurl))
-                    continue;
+        if (!getenv("NO_CURL_CHECK"))
+            if (!valid(fileurl))
+                continue;
 
-            return download(fileurl, outdir);
-        }
+        return download(fileurl, outdir);
+    }
 
-        _error = file + " is missing on server";
+    _error = file + " is missing on server";
 
-        return false;
-    }
-}
\ No newline at end of file
+    return false;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/downloader.hh b/libpkgupd/downloader.hh
index 5cb1749..d732e46 100644
--- a/libpkgupd/downloader.hh
+++ b/libpkgupd/downloader.hh
@@ -3,29 +3,26 @@
 
 #include "defines.hh"
 
-namespace rlxos::libpkgupd
-{
-    class downloader : public object
-    {
-    private:
-        std::vector<std::string> _urls;
+namespace rlxos::libpkgupd {
+class downloader : public object {
+   private:
+    std::vector<std::string> _urls;
 
-        bool valid(std::string const &url);
+    bool valid(std::string const &url);
 
-        static size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *fstream);
+    static size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *fstream);
 
-    public:
-        downloader()
-        {
-        }
+   public:
+    downloader() {
+    }
 
-        METHOD(std::vector<std::string>, urls);
+    METHOD(std::vector<std::string>, urls);
 
-        bool get(std::string const &file, std::string const &out);
+    bool get(std::string const &file, std::string const &out);
 
-        bool download(std::string const &url, std::string const &out);
-    };
+    bool download(std::string const &url, std::string const &out);
+};
 
-}
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/exec.hh b/libpkgupd/exec.hh
index 03918c6..462f88d 100644
--- a/libpkgupd/exec.hh
+++ b/libpkgupd/exec.hh
@@ -1,73 +1,67 @@
 #ifndef _PKGUPD_EXEC_HH_
 #define _PKGUPD_EXEC_HH_
 
-#include <vector>
-#include <string>
+#include <unistd.h>
+
 #include <array>
 #include <memory>
-#include <unistd.h>
+#include <string>
+#include <vector>
+
 #include "colors.hh"
 
-namespace rlxos::libpkgupd
-{
-    class exec : public object
-    {
-    private:
-        std::string _get_cmd(std::string const &cmd, std::string const &dir,
-                             std::vector<std::string> const &env = {})
-        {
-            std::string _cmd = "set -e; set -u\n";
+namespace rlxos::libpkgupd {
+class exec : public object {
+   private:
+    std::string _get_cmd(std::string const &cmd, std::string const &dir,
+                         std::vector<std::string> const &env = {}) {
+        std::string _cmd = "set -e; set -u\n";
 
-            for (auto const &i : env)
-                _cmd += "export " + i + "\n";
+        for (auto const &i : env)
+            _cmd += "export " + i + "\n";
 
-            if (dir != ".")
-                _cmd += "cd " + dir + "\n";
+        if (dir != ".")
+            _cmd += "cd " + dir + "\n";
 
-            _cmd += cmd;
+        _cmd += cmd;
 
-            return _cmd;
-        }
+        return _cmd;
+    }
 
-    public:
-        exec()
-        {
-        }
-        int execute(std::string const &command,
-                    std::string const &dir = ".",
-                    std::vector<std::string> const &environ = {})
-        {
-            auto cmd = _get_cmd(command, dir, environ);
-            DEBUG("executing: '" << cmd << "'");
-            return WEXITSTATUS(system(cmd.c_str()));
-        }
+   public:
+    exec() {
+    }
+    int execute(std::string const &command,
+                std::string const &dir = ".",
+                std::vector<std::string> const &environ = {}) {
+        auto cmd = _get_cmd(command, dir, environ);
+        DEBUG("executing: '" << cmd << "'");
+        return WEXITSTATUS(system(cmd.c_str()));
+    }
 
-        std::tuple<int, std::string> output(
-            std::string const &command,
-            std::string const &dir = ".",
-            std::vector<std::string> const &environ = {})
-        {
-            auto cmd = _get_cmd(command, dir, environ);
+    std::tuple<int, std::string> output(
+        std::string const &command,
+        std::string const &dir = ".",
+        std::vector<std::string> const &environ = {}) {
+        auto cmd = _get_cmd(command, dir, environ);
 
-            std::array<char, 128> buffer;
-            std::string result;
-            FILE *pipe = popen(cmd.c_str(), "r");
-            if (!pipe)
-            {
-                throw std::runtime_error("popen() failed!");
-            }
-            while (fgets(buffer.data(), buffer.size(), pipe) != nullptr)
-            {
-                result += buffer.data();
-            }
+        std::array<char, 128> buffer;
+        std::string result;
+        FILE *pipe = popen(cmd.c_str(), "r");
+        if (!pipe) {
+            throw std::runtime_error("popen() failed!");
+        }
+        while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {
+            result += buffer.data();
+        }
 
-            int status = WEXITSTATUS(pclose(pipe));
-            if (status != 0)
-                _error = "Failed to execute " + cmd;
+        int status = WEXITSTATUS(pclose(pipe));
+        if (status != 0)
+            _error = "Failed to execute " + cmd;
 
-            return {status, result};
-        }
-    };
-}
+        return {status, result};
+    }
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/installer.cc b/libpkgupd/installer.cc
index ce3d88f..2f72645 100644
--- a/libpkgupd/installer.cc
+++ b/libpkgupd/installer.cc
@@ -1,131 +1,108 @@
 #include "installer.hh"
-#include "archive.hh"
-
-#include "triggerer.hh"
 
-#include <iostream>
 #include <cassert>
+#include <iostream>
 
-namespace rlxos::libpkgupd
-{
+#include "archive.hh"
+#include "triggerer.hh"
 
-    bool installer::_install(std::vector<std::string> const &pkgs,
-                             std::string const &root_dir,
-                             bool skip_triggers,
-                             bool force)
-    {
-        std::vector<std::shared_ptr<pkginfo>> pkginfo_list;
-        std::vector<std::vector<std::string>> all_pkgs_fileslist;
+namespace rlxos::libpkgupd {
 
-        for (auto const &i : pkgs)
-        {
-            auto archive_ = archive(i);
+bool installer::_install(std::vector<std::string> const &pkgs,
+                         std::string const &root_dir,
+                         bool skip_triggers,
+                         bool force) {
+    std::vector<std::shared_ptr<pkginfo>> pkginfo_list;
+    std::vector<std::vector<std::string>> all_pkgs_fileslist;
 
-            PROCESS("Getting information from " << std::filesystem::path(i).filename().string());
+    for (auto const &i : pkgs) {
+        auto archive_ = archive(i);
 
-            auto info = archive_.info();
-            if (info == nullptr)
-            {
-                _error = archive_.error();
-                return false;
-            }
+        PROCESS("Getting information from " << std::filesystem::path(i).filename().string());
 
-            try
-            {
-                if (!force)
-                {
-                    if (_sysdb.is_installed(info) && !_sysdb.outdated(info))
-                    {
-                        INFO(info->id() + " latest version is already installed")
-                        continue;
-                    }
+        auto info = archive_.info();
+        if (info == nullptr) {
+            _error = archive_.error();
+            return false;
+        }
+
+        try {
+            if (!force) {
+                if (_sysdb.is_installed(info) && !_sysdb.outdated(info)) {
+                    INFO(info->id() + " latest version is already installed")
+                    continue;
                 }
             }
-            catch (...)
-            {
-            }
+        } catch (...) {
+        }
 
-            PROCESS("extracting " << info->id() << " into " << root_dir);
-            if (!archive_.extract(root_dir))
-            {
-                _error = archive_.error();
-                return false;
-            }
-            all_pkgs_fileslist.push_back(archive_.list());
-            pkginfo_list.push_back(info);
+        PROCESS("extracting " << info->id() << " into " << root_dir);
+        if (!archive_.extract(root_dir)) {
+            _error = archive_.error();
+            return false;
         }
+        all_pkgs_fileslist.push_back(archive_.list());
+        pkginfo_list.push_back(info);
+    }
 
-        assert(all_pkgs_fileslist.size() == pkginfo_list.size());
+    assert(all_pkgs_fileslist.size() == pkginfo_list.size());
 
-        for (int i = 0; i < pkginfo_list.size(); i++)
-        {
-            PROCESS("Registering " << pkginfo_list[i]->id() << " into system database");
-            if (!_sysdb.add(pkginfo_list[i], all_pkgs_fileslist[i], root_dir, force))
-            {
-                _error = _sysdb.error();
-                return false;
-            }
+    for (int i = 0; i < pkginfo_list.size(); i++) {
+        PROCESS("Registering " << pkginfo_list[i]->id() << " into system database");
+        if (!_sysdb.add(pkginfo_list[i], all_pkgs_fileslist[i], root_dir, force)) {
+            _error = _sysdb.error();
+            return false;
         }
+    }
 
-        if (skip_triggers)
-        {
-            INFO("Skipping Triggers")
+    if (skip_triggers) {
+        INFO("Skipping Triggers")
+    } else {
+        auto triggerer_ = triggerer();
+        if (!triggerer_.trigger(all_pkgs_fileslist)) {
+            _error = triggerer_.error();
+            return false;
         }
-        else
-        {
-            auto triggerer_ = triggerer();
-            if (!triggerer_.trigger(all_pkgs_fileslist))
-            {
-                _error = triggerer_.error();
-                return false;
-            }
-        }
-
-        return true;
     }
-    bool installer::install(std::vector<std::string> const &pkgs,
-                            std::string const &root_dir,
-                            bool skip_triggers,
-                            bool force)
-    {
-        std::vector<std::string> archive_list;
-
-        for (auto const &i : pkgs)
-        {
-            if (std::filesystem::exists(i))
-            {
-                archive_list.push_back(i);
-                continue;
-            }
 
-            auto info = _repodb[i];
-            if (info == nullptr)
-            {
-                _error = "no package found with name '" + i + "'";
-                return false;
-            }
+    return true;
+}
+bool installer::install(std::vector<std::string> const &pkgs,
+                        std::string const &root_dir,
+                        bool skip_triggers,
+                        bool force) {
+    std::vector<std::string> archive_list;
+
+    for (auto const &i : pkgs) {
+        if (std::filesystem::exists(i)) {
+            archive_list.push_back(i);
+            continue;
+        }
 
-            if (_sysdb.is_installed(info) && !force)
-            {
-                _error = info->id() + " is already installed in the system";
-                return false;
-            }
+        auto info = _repodb[i];
+        if (info == nullptr) {
+            _error = "no package found with name '" + i + "'";
+            return false;
+        }
 
-            auto pkgfile = info->packagefile();
-            auto pkgpath = _pkg_dir + "/" + pkgfile;
+        if (_sysdb.is_installed(info) && !force) {
+            _error = info->id() + " is already installed in the system";
+            return false;
+        }
 
-            if (!std::filesystem::exists(pkgpath))
-            {
-                if (!_downloader.get(pkgfile, pkgpath))
-                {
-                    _error = _downloader.error();
-                    return false;
-                }
-            }
+        auto pkgfile = info->packagefile();
+        auto pkgpath = _pkg_dir + "/" + pkgfile;
 
-            archive_list.push_back(pkgpath);
+        if (!std::filesystem::exists(pkgpath)) {
+            if (!_downloader.get(pkgfile, pkgpath)) {
+                _error = _downloader.error();
+                return false;
+            }
         }
 
-        return _install(archive_list, root_dir, skip_triggers, force);
+        archive_list.push_back(pkgpath);
     }
-}
\ No newline at end of file
+
+    return _install(archive_list, root_dir, skip_triggers, force);
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/installer.hh b/libpkgupd/installer.hh
index 48c446f..496cd65 100644
--- a/libpkgupd/installer.hh
+++ b/libpkgupd/installer.hh
@@ -2,43 +2,40 @@
 #define _INSTALLER_HH_
 
 #include "defines.hh"
-#include "sysdb.hh"
-#include "repodb.hh"
 #include "downloader.hh"
+#include "repodb.hh"
+#include "sysdb.hh"
 
-namespace rlxos::libpkgupd
-{
-    class installer : public object
-    {
-    private:
-        sysdb _sysdb;
-        repodb _repodb;
-        downloader _downloader;
+namespace rlxos::libpkgupd {
+class installer : public object {
+   private:
+    sysdb _sysdb;
+    repodb _repodb;
+    downloader _downloader;
 
-        std::string _pkg_dir;
+    std::string _pkg_dir;
 
-        bool _install(std::vector<std::string> const &pkgs,
-                      std::string const &root_dir,
-                      bool skip_triggers,
-                      bool force);
+    bool _install(std::vector<std::string> const &pkgs,
+                  std::string const &root_dir,
+                  bool skip_triggers,
+                  bool force);
 
-    public:
-        installer(sysdb &sdb,
-                  repodb &rdb,
-                  downloader &dwn,
-                  std::string const &pkgdir)
-            : _sysdb{sdb},
-              _repodb{rdb},
-              _downloader{dwn},
-              _pkg_dir{pkgdir}
-        {
-        }
+   public:
+    installer(sysdb &sdb,
+              repodb &rdb,
+              downloader &dwn,
+              std::string const &pkgdir)
+        : _sysdb{sdb},
+          _repodb{rdb},
+          _downloader{dwn},
+          _pkg_dir{pkgdir} {
+    }
 
-        bool install(std::vector<std::string> const &pkgs,
-                      std::string const &root_dir,
-                      bool skip_triggers,
-                      bool force);
-    };
-}
+    bool install(std::vector<std::string> const &pkgs,
+                 std::string const &root_dir,
+                 bool skip_triggers,
+                 bool force);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/pkginfo.hh b/libpkgupd/pkginfo.hh
index 469ee9a..76e6736 100644
--- a/libpkgupd/pkginfo.hh
+++ b/libpkgupd/pkginfo.hh
@@ -3,22 +3,19 @@
 
 #include "defines.hh"
 
-namespace rlxos::libpkgupd
-{
-    class pkginfo
-    {
-    public:
-        virtual std::string id() const = 0;
-        virtual std::string version() const = 0;
-        virtual std::string about() const = 0;
+namespace rlxos::libpkgupd {
+class pkginfo {
+   public:
+    virtual std::string id() const = 0;
+    virtual std::string version() const = 0;
+    virtual std::string about() const = 0;
 
-        virtual std::string packagefile(std::string ext = DEFAULT_EXTENSION) const
-        {
-            return id() + "-" + version() + "." + ext;
-        }
+    virtual std::string packagefile(std::string ext = DEFAULT_EXTENSION) const {
+        return id() + "-" + version() + "." + ext;
+    }
 
-        virtual std::vector<std::string> depends(bool) const = 0;
-    };
-}
+    virtual std::vector<std::string> depends(bool) const = 0;
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/recipe.cc b/libpkgupd/recipe.cc
index 44e08f2..187b384 100644
--- a/libpkgupd/recipe.cc
+++ b/libpkgupd/recipe.cc
@@ -2,8 +2,8 @@
 
 #include <yaml-cpp/yaml.h>
 
+#include <algorithm>  // find_if
 #include <iostream>
-#include <algorithm> // find_if
 
 using std::string;
 
@@ -13,141 +13,125 @@ using std::string;
     READ_LIST_FROM(string, runtime, depends, runtime_depends); \
     READ_LIST_FROM(string, buildtime, depends, buildtime_depends);
 
-namespace rlxos::libpkgupd
-{
+namespace rlxos::libpkgupd {
 
-    recipe::recipe(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(string, id);
-        READ_VALUE(string, version);
-        READ_VALUE(string, about);
+recipe::recipe(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(string, id);
+    READ_VALUE(string, version);
+    READ_VALUE(string, about);
 
-        READ_COMMON();
+    READ_COMMON();
 
-        READ_OBJECT_LIST(user, users);
-        READ_OBJECT_LIST(group, groups);
+    READ_OBJECT_LIST(user, users);
+    READ_OBJECT_LIST(group, groups);
 
-        READ_OBJECT_LIST(package, packages);
-    }
-
-    recipe::package::package(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(string, id);
-        READ_VALUE(string, dir);
-
-        READ_COMMON();
+    READ_OBJECT_LIST(package, packages);
+}
 
-        OPTIONAL_VALUE(string, prescript, "");
-        OPTIONAL_VALUE(string, postscript, "");
-        OPTIONAL_VALUE(string, script, "");
-        OPTIONAL_VALUE(string, preinstall, "");
-        OPTIONAL_VALUE(string, postscript, "");
+recipe::package::package(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(string, id);
+    READ_VALUE(string, dir);
 
-        OPTIONAL_VALUE(string, pack, "rlx");
+    READ_COMMON();
 
-        READ_LIST(string, skipstrip);
-        OPTIONAL_VALUE(bool, strip, true);
-
-        READ_OBJECT_LIST(flag, flags);
-    }
-
-    recipe::package::flag::flag(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(string, id);
-        READ_VALUE(string, value);
-
-        OPTIONAL_VALUE(bool, force, false);
-        if (data["only"])
-        {
-            INFO("Use of 'only' in flags is deprecated, use 'force'")
-            _force = data["only"].as<bool>();
-        }
-    }
-
-    recipe::user::user(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(unsigned int, id);
-        READ_VALUE(string, name);
-        READ_VALUE(string, about);
-        READ_VALUE(string, group);
-        READ_VALUE(string, dir);
-        READ_VALUE(string, shell);
-    }
+    OPTIONAL_VALUE(string, prescript, "");
+    OPTIONAL_VALUE(string, postscript, "");
+    OPTIONAL_VALUE(string, script, "");
+    OPTIONAL_VALUE(string, preinstall, "");
+    OPTIONAL_VALUE(string, postscript, "");
 
-    recipe::group::group(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(unsigned int, id);
-        READ_VALUE(string, name);
-    }
+    OPTIONAL_VALUE(string, pack, "rlx");
 
-    std::string recipe::package::id() const
-    {
-        if (_id == "lib" ||
-            _id == "lib32")
-            return _id + _parent->id();
+    READ_LIST(string, skipstrip);
+    OPTIONAL_VALUE(bool, strip, true);
 
-        if (_id == "pkg")
-            return _parent->_id;
+    READ_OBJECT_LIST(flag, flags);
+}
 
-        return _parent->_id + "-" + _id;
-    }
+recipe::package::flag::flag(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(string, id);
+    READ_VALUE(string, value);
 
-    std::string recipe::package::version() const
-    {
-        return _parent->_version;
+    OPTIONAL_VALUE(bool, force, false);
+    if (data["only"]) {
+        INFO("Use of 'only' in flags is deprecated, use 'force'")
+        _force = data["only"].as<bool>();
     }
-
-    std::string recipe::package::about() const
-    {
-        return _parent->_about;
+}
+
+recipe::user::user(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(unsigned int, id);
+    READ_VALUE(string, name);
+    READ_VALUE(string, about);
+    READ_VALUE(string, group);
+    READ_VALUE(string, dir);
+    READ_VALUE(string, shell);
+}
+
+recipe::group::group(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(unsigned int, id);
+    READ_VALUE(string, name);
+}
+
+std::string recipe::package::id() const {
+    if (_id == "lib" ||
+        _id == "lib32")
+        return _id + _parent->id();
+
+    if (_id == "pkg")
+        return _parent->_id;
+
+    return _parent->_id + "-" + _id;
+}
+
+std::string recipe::package::version() const {
+    return _parent->_version;
+}
+
+std::string recipe::package::about() const {
+    return _parent->_about;
+}
+
+std::vector<std::string> recipe::package::depends(bool all) const {
+    std::vector<string> depends = _runtime_depends;
+    depends.insert(depends.end(), _parent->_runtime_depends.begin(), _parent->_runtime_depends.end());
+
+    if (all) {
+        depends.insert(depends.end(), _buildtime_depends.begin(), _buildtime_depends.end());
+        depends.insert(depends.end(), _parent->_buildtime_depends.begin(), _parent->_buildtime_depends.end());
     }
 
-    std::vector<std::string> recipe::package::depends(bool all) const
-    {
-        std::vector<string> depends = _runtime_depends;
-        depends.insert(depends.end(), _parent->_runtime_depends.begin(), _parent->_runtime_depends.end());
+    return depends;
+}
 
-        if (all)
-        {
-            depends.insert(depends.end(), _buildtime_depends.begin(), _buildtime_depends.end());
-            depends.insert(depends.end(), _parent->_buildtime_depends.begin(), _parent->_buildtime_depends.end());
-        }
+std::vector<std::string> recipe::package::sources() const {
+    std::vector<std::string> all_sources = _sources;
+    all_sources.insert(all_sources.end(), _parent->_sources.begin(), _parent->_sources.end());
+    return all_sources;
+}
 
-        return depends;
-    }
+std::vector<std::string> recipe::package::environ() {
+    std::vector<std::string> allenviron = _parent->_environ;
+    allenviron.insert(allenviron.end(), _environ.begin(), _environ.end());
+    return allenviron;
+}
 
-    std::vector<std::string> recipe::package::sources() const
-    {
-        std::vector<std::string> all_sources = _sources;
-        all_sources.insert(all_sources.end(), _parent->_sources.begin(), _parent->_sources.end());
-        return all_sources;
-    }
+std::shared_ptr<recipe::package> recipe::operator[](std::string const &pkgid) const {
+    auto pkgiter = std::find_if(
+        _packages.begin(), _packages.end(),
+        [&](std::shared_ptr<package> const &p) {
+            if (pkgid == this->id() && (p->id() == "pkg"))
+                return true;
 
-    std::vector<std::string> recipe::package::environ()
-    {
-        std::vector<std::string> allenviron = _parent->_environ;
-        allenviron.insert(allenviron.end(), _environ.begin(), _environ.end());
-        return allenviron;
-    }
-
-    std::shared_ptr<recipe::package> recipe::operator[](std::string const &pkgid) const
-    {
-        auto pkgiter = std::find_if(
-            _packages.begin(), _packages.end(),
-            [&](std::shared_ptr<package> const &p)
-            {
-                if (pkgid == this->id() && (p->id() == "pkg"))
-                    return true;
+            if (pkgid == p->id())
+                return true;
 
-                if (pkgid == p->id())
-                    return true;
+            return false;
+        });
 
-                return false;
-            });
+    if (pkgiter == _packages.end())
+        return nullptr;
 
-        if (pkgiter == _packages.end())
-            return nullptr;
-
-        return (*pkgiter);
-    }
-}
\ No newline at end of file
+    return (*pkgiter);
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/recipe.hh b/libpkgupd/recipe.hh
index 2ddf186..aefaec5 100644
--- a/libpkgupd/recipe.hh
+++ b/libpkgupd/recipe.hh
@@ -1,195 +1,186 @@
 #ifndef _PKGUPD_PKGINFO_HH_
 #define _PKGUPD_PKGINFO_HH_
 
+#include <yaml-cpp/yaml.h>
+
 #include <string>
 #include <vector>
-#include <yaml-cpp/yaml.h>
+
 #include "pkginfo.hh"
 
-namespace rlxos::libpkgupd
-{
-
-    class recipe : public std::enable_shared_from_this<recipe>
-    {
-    public:
-        class user
-        {
-        private:
-            unsigned int _id;
-            std::string _name, _about, _dir, _shell, _group;
-
-        public:
-            user(unsigned int id,
-                 std::string const &name,
-                 std::string const &about,
-                 std::string const &dir,
-                 std::string const &shell,
-                 std::string const &group)
-                : _id(id),
-                  _name(name),
-                  _about(about),
-                  _dir(dir),
-                  _shell(shell),
-                  _group(group)
-            {
-            }
-
-            user(YAML::Node const &data, std::string const &file);
-
-            bool exists() const;
-
-            bool create() const;
-        };
+namespace rlxos::libpkgupd {
+
+class recipe : public std::enable_shared_from_this<recipe> {
+   public:
+    class user {
+       private:
+        unsigned int _id;
+        std::string _name, _about, _dir, _shell, _group;
+
+       public:
+        user(unsigned int id,
+             std::string const &name,
+             std::string const &about,
+             std::string const &dir,
+             std::string const &shell,
+             std::string const &group)
+            : _id(id),
+              _name(name),
+              _about(about),
+              _dir(dir),
+              _shell(shell),
+              _group(group) {
+        }
+
+        user(YAML::Node const &data, std::string const &file);
 
-        class group
-        {
-        private:
-            unsigned int _id;
-            std::string _name;
+        bool exists() const;
 
-        public:
-            group(unsigned int id,
-                  std::string const &name)
-                : _id(id),
-                  _name(name) {}
+        bool create() const;
+    };
 
-            group(YAML::Node const &data, std::string const &file);
+    class group {
+       private:
+        unsigned int _id;
+        std::string _name;
 
-            bool exists() const;
+       public:
+        group(unsigned int id,
+              std::string const &name)
+            : _id(id),
+              _name(name) {}
 
-            bool create() const;
-        };
+        group(YAML::Node const &data, std::string const &file);
 
-        class package : public pkginfo
-        {
-        public:
-            class flag
-            {
-            private:
-                std::string _id, _value;
+        bool exists() const;
 
-                bool _force;
+        bool create() const;
+    };
 
-            public:
-                flag(YAML::Node const &data, std::string const &file);
+    class package : public pkginfo {
+       public:
+        class flag {
+           private:
+            std::string _id, _value;
 
-                GET_METHOD(std::string, id);
-                GET_METHOD(std::string, value);
-                GET_METHOD(bool, force);
-            };
+            bool _force;
 
-        private:
-            std::string _id,
-                _dir;
-            bool _strip;
+           public:
+            flag(YAML::Node const &data, std::string const &file);
 
-            std::string _pack;
+            GET_METHOD(std::string, id);
+            GET_METHOD(std::string, value);
+            GET_METHOD(bool, force);
+        };
 
-            std::vector<std::string> _skipstrip;
+       private:
+        std::string _id,
+            _dir;
+        bool _strip;
 
-            std::vector<std::string> _runtime_depends;
-            std::vector<std::string> _buildtime_depends;
+        std::string _pack;
+
+        std::vector<std::string> _skipstrip;
+
+        std::vector<std::string> _runtime_depends;
+        std::vector<std::string> _buildtime_depends;
 
-            std::vector<std::string> _sources;
+        std::vector<std::string> _sources;
 
-            std::vector<std::string> _environ;
+        std::vector<std::string> _environ;
 
-            std::string _script;
-            std::string _prescript, _postscript;
-            std::string _preinstall, _postinstall;
+        std::string _script;
+        std::string _prescript, _postscript;
+        std::string _preinstall, _postinstall;
 
-            std::vector<std::shared_ptr<flag>> _flags;
+        std::vector<std::shared_ptr<flag>> _flags;
 
-            std::shared_ptr<recipe> _parent;
+        std::shared_ptr<recipe> _parent;
 
-        public:
-            package(YAML::Node const &data, std::string const &file);
+       public:
+        package(YAML::Node const &data, std::string const &file);
 
-            METHOD(std::shared_ptr<recipe>, parent);
+        METHOD(std::shared_ptr<recipe>, parent);
 
-            std::string id() const;
+        std::string id() const;
 
-            std::string version() const;
+        std::string version() const;
 
-            std::string about() const;
+        std::string about() const;
 
-            std::vector<std::string> depends(bool all) const;
+        std::vector<std::string> depends(bool all) const;
 
-            std::vector<std::string> sources() const;
+        std::vector<std::string> sources() const;
 
-            GET_METHOD(std::string, script);
-            GET_METHOD(std::string, prescript);
-            GET_METHOD(std::string, postscript);
+        GET_METHOD(std::string, script);
+        GET_METHOD(std::string, prescript);
+        GET_METHOD(std::string, postscript);
 
-            GET_METHOD(std::vector<std::shared_ptr<flag>>, flags);
+        GET_METHOD(std::vector<std::shared_ptr<flag>>, flags);
 
-            GET_METHOD(std::string, pack);
+        GET_METHOD(std::string, pack);
 
-            GET_METHOD(std::string, dir);
+        GET_METHOD(std::string, dir);
 
-            GET_METHOD(std::vector<std::string>, skipstrip);
+        GET_METHOD(std::vector<std::string>, skipstrip);
 
-            GET_METHOD(bool, strip);
+        GET_METHOD(bool, strip);
 
-            std::vector<std::string> environ();
+        std::vector<std::string> environ();
 
-            void prepand_environ(std::string const &env)
-            {
-                _environ.insert(_environ.begin(), env);
-            }
+        void prepand_environ(std::string const &env) {
+            _environ.insert(_environ.begin(), env);
+        }
 
-            void append_environ(std::string const &env)
-            {
-                _environ.push_back(env);
-            }
-        };
+        void append_environ(std::string const &env) {
+            _environ.push_back(env);
+        }
+    };
 
-    private:
-        std::string _id;
-        std::string _version;
-        std::string _about;
+   private:
+    std::string _id;
+    std::string _version;
+    std::string _about;
 
-        std::vector<std::string> _runtime_depends;
-        std::vector<std::string> _buildtime_depends;
+    std::vector<std::string> _runtime_depends;
+    std::vector<std::string> _buildtime_depends;
 
-        std::vector<std::string> _sources;
+    std::vector<std::string> _sources;
 
-        std::vector<std::string> _environ;
+    std::vector<std::string> _environ;
 
-        std::vector<std::shared_ptr<user>> _users;
-        std::vector<std::shared_ptr<group>> _groups;
+    std::vector<std::shared_ptr<user>> _users;
+    std::vector<std::shared_ptr<group>> _groups;
 
-        std::vector<std::shared_ptr<package>> _packages;
+    std::vector<std::shared_ptr<package>> _packages;
 
-    public:
-        recipe(YAML::Node const &node, std::string const &file);
+   public:
+    recipe(YAML::Node const &node, std::string const &file);
 
-        static std::shared_ptr<recipe> from_filepath(std::string const &filepath)
-        {
-            auto ptr = std::make_shared<recipe>(YAML::LoadFile(filepath), filepath);
-            for (auto &pkg : ptr->_packages)
-                pkg->parent(ptr->shared_from_this());
+    static std::shared_ptr<recipe> from_filepath(std::string const &filepath) {
+        auto ptr = std::make_shared<recipe>(YAML::LoadFile(filepath), filepath);
+        for (auto &pkg : ptr->_packages)
+            pkg->parent(ptr->shared_from_this());
 
-            return ptr;
-        }
+        return ptr;
+    }
 
-        static std::shared_ptr<recipe> from_yaml(YAML::Node const &node)
-        {
-            auto ptr = std::make_shared<recipe>(node, "");
-            for (auto &pkg : ptr->_packages)
-                pkg->parent(ptr->shared_from_this());
+    static std::shared_ptr<recipe> from_yaml(YAML::Node const &node) {
+        auto ptr = std::make_shared<recipe>(node, "");
+        for (auto &pkg : ptr->_packages)
+            pkg->parent(ptr->shared_from_this());
 
-            return ptr;
-        }
+        return ptr;
+    }
 
-        std::shared_ptr<package> operator[](std::string const &pkgid) const;
+    std::shared_ptr<package> operator[](std::string const &pkgid) const;
 
-        GET_METHOD(std::vector<std::shared_ptr<package>>, packages);
-        GET_METHOD(std::string, id);
+    GET_METHOD(std::vector<std::shared_ptr<package>>, packages);
+    GET_METHOD(std::string, id);
 
-        friend class recipe::package;
-    };
+    friend class recipe::package;
+};
 
-}
+}  // namespace rlxos::libpkgupd
 
 #endif
diff --git a/libpkgupd/remover.cc b/libpkgupd/remover.cc
index 77234b4..f550dc7 100644
--- a/libpkgupd/remover.cc
+++ b/libpkgupd/remover.cc
@@ -1,87 +1,73 @@
 #include "remover.hh"
 
-namespace rlxos::libpkgupd
-{
-    bool remover::remove(std::shared_ptr<sysdb::package> pkginfo_)
-    {
-        auto files = pkginfo_->files();
-
-        bool status = true;
-
-        _files_list.push_back(std::vector<std::string>());
-
-        for (auto i = files.rbegin(); i != files.rend(); i++)
-        {
-            std::error_code err;
-            std::string path;
-
-            if ((*i).rfind("./", 0) == 0)
-                path = _root_dir + "/" + (*i).substr(2, (*i).length() - 2);
-            else
-                path = _root_dir + "/" + *i;
-
-            if (std::filesystem::is_directory(path))
-            {
-                _files_list.back().push_back(path);
-
-                if (std::filesystem::is_empty(path))
-                    std::filesystem::remove_all(path, err);
-            }
-            else
-            {
-                DEBUG("removing " << path);
-                std::filesystem::remove(path, err);
-                _files_list.back().push_back(path);
-            }
-
-            if (err)
-            {
-                _error += "\n" + err.message();
-                status = false;
-            }
+namespace rlxos::libpkgupd {
+bool remover::remove(std::shared_ptr<sysdb::package> pkginfo_) {
+    auto files = pkginfo_->files();
+
+    bool status = true;
+
+    _files_list.push_back(std::vector<std::string>());
+
+    for (auto i = files.rbegin(); i != files.rend(); i++) {
+        std::error_code err;
+        std::string path;
+
+        if ((*i).rfind("./", 0) == 0)
+            path = _root_dir + "/" + (*i).substr(2, (*i).length() - 2);
+        else
+            path = _root_dir + "/" + *i;
+
+        if (std::filesystem::is_directory(path)) {
+            _files_list.back().push_back(path);
+
+            if (std::filesystem::is_empty(path))
+                std::filesystem::remove_all(path, err);
+        } else {
+            DEBUG("removing " << path);
+            std::filesystem::remove(path, err);
+            _files_list.back().push_back(path);
         }
 
-        if(!_sys_db.remove(pkginfo_))
-        {
-            _error += _sys_db.error();
+        if (err) {
+            _error += "\n" + err.message();
             status = false;
         }
+    }
 
-        return status;
+    if (!_sys_db.remove(pkginfo_)) {
+        _error += _sys_db.error();
+        status = false;
     }
 
-    bool remover::remove(std::vector<std::string> const &pkgs, bool skip_triggers)
-    {
-        std::vector<std::shared_ptr<sysdb::package>> pkgsInfo;
+    return status;
+}
 
-        for (auto const &i : pkgs)
-        {
-            auto pkginfo_ = _sys_db[i];
-            if (pkginfo_ == nullptr)
-            {
-                _error = _sys_db.error();
-                return false;
-            }
+bool remover::remove(std::vector<std::string> const &pkgs, bool skip_triggers) {
+    std::vector<std::shared_ptr<sysdb::package>> pkgsInfo;
 
-            pkgsInfo.push_back(std::dynamic_pointer_cast<sysdb::package>(pkginfo_));
+    for (auto const &i : pkgs) {
+        auto pkginfo_ = _sys_db[i];
+        if (pkginfo_ == nullptr) {
+            _error = _sys_db.error();
+            return false;
         }
 
-        for (auto const &i : pkgsInfo)
-        {
-            PROCESS("cleaning file of " << i->id());
-            if (!remove(i))
-                ERROR(_error);
-        }
+        pkgsInfo.push_back(std::dynamic_pointer_cast<sysdb::package>(pkginfo_));
+    }
 
-        if (!skip_triggers)
-        {
-            if (!_triggerer.trigger(_files_list))
-            {
-                _error = _triggerer.error();
-                return false;
-            }
-        }
+    for (auto const &i : pkgsInfo) {
+        PROCESS("cleaning file of " << i->id());
+        if (!remove(i))
+            ERROR(_error);
+    }
 
-        return true;
+    if (!skip_triggers) {
+        if (!_triggerer.trigger(_files_list)) {
+            _error = _triggerer.error();
+            return false;
+        }
     }
-}
\ No newline at end of file
+
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/remover.hh b/libpkgupd/remover.hh
index 6848514..7ebc12d 100644
--- a/libpkgupd/remover.hh
+++ b/libpkgupd/remover.hh
@@ -5,30 +5,27 @@
 #include "sysdb.hh"
 #include "triggerer.hh"
 
-namespace rlxos::libpkgupd
-{
-    class remover : public object
-    {
-    private:
-        std::string _root_dir;
-        sysdb _sys_db;
-        triggerer _triggerer;
-
-        std::vector<std::vector<std::string>> _files_list;
-
-        bool _skip_trigger = false;
-
-    public:
-        remover(sysdb &sdb, std::string const &rootdir)
-            : _sys_db{sdb},
-              _root_dir{rootdir}
-        {
-        }
-
-        bool remove(std::shared_ptr<sysdb::package> pkginfo_);
-
-        bool remove(std::vector<std::string> const &pkgs, bool skip_triggers = false);
-    };
-}
+namespace rlxos::libpkgupd {
+class remover : public object {
+   private:
+    std::string _root_dir;
+    sysdb _sys_db;
+    triggerer _triggerer;
+
+    std::vector<std::vector<std::string>> _files_list;
+
+    bool _skip_trigger = false;
+
+   public:
+    remover(sysdb &sdb, std::string const &rootdir)
+        : _sys_db{sdb},
+          _root_dir{rootdir} {
+    }
+
+    bool remove(std::shared_ptr<sysdb::package> pkginfo_);
+
+    bool remove(std::vector<std::string> const &pkgs, bool skip_triggers = false);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/repodb.cc b/libpkgupd/repodb.cc
index e0df2c6..9ba539a 100644
--- a/libpkgupd/repodb.cc
+++ b/libpkgupd/repodb.cc
@@ -1,78 +1,65 @@
 #include "repodb.hh"
-#include "recipe.hh"
 
-namespace rlxos::libpkgupd
-{
-    std::shared_ptr<pkginfo> repodb::operator[](std::string const &pkgid)
-    {
-        auto direct_path = std::filesystem::path(_data_dir) / (pkgid + ".yml");
-        if (std::filesystem::exists(direct_path))
-        {
-            std::shared_ptr<recipe> recipe_;
-            try
-            {
-                recipe_ = recipe::from_filepath(direct_path);
-            }
-            catch (YAML::Exception const &ee)
-            {
-                _error = "failed to read recipe file '" + direct_path.string() + "' " + std::string(ee.what());
-                return nullptr;
-            }
+#include "recipe.hh"
 
-            auto pkginfo_ = (*recipe_)[pkgid];
-            if (pkginfo_ == nullptr)
-            {
-                _error = "no package with id '" + pkgid + "' found in recipe file " + direct_path.string();
-                return nullptr;
-            }
-            return pkginfo_;
+namespace rlxos::libpkgupd {
+std::shared_ptr<pkginfo> repodb::operator[](std::string const &pkgid) {
+    auto direct_path = std::filesystem::path(_data_dir) / (pkgid + ".yml");
+    if (std::filesystem::exists(direct_path)) {
+        std::shared_ptr<recipe> recipe_;
+        try {
+            recipe_ = recipe::from_filepath(direct_path);
+        } catch (YAML::Exception const &ee) {
+            _error = "failed to read recipe file '" + direct_path.string() + "' " + std::string(ee.what());
+            return nullptr;
         }
 
-        // if sub package lib32
-        std::string _try_rcp_file;
-
-        if (pkgid.rfind("lib32", 0) == 0 && pkgid.length() > 6)
-            _try_rcp_file = pkgid.substr(5, pkgid.length() - 5);
-        else if (pkgid.rfind("lib", 0) == 0 && pkgid.length() > 0)
-            _try_rcp_file = pkgid.substr(3, pkgid.length() - 3);
-        else
-        {
-            size_t rdx = pkgid.find_last_of('-');
-            if (rdx == std::string::npos)
-            {
-                _error = "no package found with id '" + pkgid + "'";
-                return nullptr;
-            }
-
-            _try_rcp_file = pkgid.substr(0, rdx);
+        auto pkginfo_ = (*recipe_)[pkgid];
+        if (pkginfo_ == nullptr) {
+            _error = "no package with id '" + pkgid + "' found in recipe file " + direct_path.string();
+            return nullptr;
         }
+        return pkginfo_;
+    }
 
-        _try_rcp_file = (std::filesystem::path(_data_dir) / _try_rcp_file).string() + ".yml";
+    // if sub package lib32
+    std::string _try_rcp_file;
 
-        if (!std::filesystem::exists(_try_rcp_file))
-        {
+    if (pkgid.rfind("lib32", 0) == 0 && pkgid.length() > 6)
+        _try_rcp_file = pkgid.substr(5, pkgid.length() - 5);
+    else if (pkgid.rfind("lib", 0) == 0 && pkgid.length() > 0)
+        _try_rcp_file = pkgid.substr(3, pkgid.length() - 3);
+    else {
+        size_t rdx = pkgid.find_last_of('-');
+        if (rdx == std::string::npos) {
             _error = "no package found with id '" + pkgid + "'";
             return nullptr;
         }
 
-        std::shared_ptr<recipe> recipe_;
-        try
-        {
-            recipe_ = recipe::from_filepath(_try_rcp_file);
-        }
-        catch (YAML::Exception const &ee)
-        {
-            _error = "failed to read recipe file '" + _try_rcp_file + "' " + std::string(ee.what());
-            return nullptr;
-        }
+        _try_rcp_file = pkgid.substr(0, rdx);
+    }
 
-        auto packageInfo = (*recipe_)[pkgid];
-        if (packageInfo == nullptr)
-        {
-            _error = "no package found with id '" + pkgid + "' in detected recipe file " + _try_rcp_file;
-            return nullptr;
-        }
+    _try_rcp_file = (std::filesystem::path(_data_dir) / _try_rcp_file).string() + ".yml";
 
-        return packageInfo;
+    if (!std::filesystem::exists(_try_rcp_file)) {
+        _error = "no package found with id '" + pkgid + "'";
+        return nullptr;
     }
-}
\ No newline at end of file
+
+    std::shared_ptr<recipe> recipe_;
+    try {
+        recipe_ = recipe::from_filepath(_try_rcp_file);
+    } catch (YAML::Exception const &ee) {
+        _error = "failed to read recipe file '" + _try_rcp_file + "' " + std::string(ee.what());
+        return nullptr;
+    }
+
+    auto packageInfo = (*recipe_)[pkgid];
+    if (packageInfo == nullptr) {
+        _error = "no package found with id '" + pkgid + "' in detected recipe file " + _try_rcp_file;
+        return nullptr;
+    }
+
+    return packageInfo;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/repodb.hh b/libpkgupd/repodb.hh
index aa26730..8ff9aab 100644
--- a/libpkgupd/repodb.hh
+++ b/libpkgupd/repodb.hh
@@ -3,19 +3,16 @@
 
 #include "db.hh"
 
-namespace rlxos::libpkgupd
-{
-    class repodb : public db
-    {
-    public:
-        repodb(std::string const &data_dir)
-            : db(data_dir)
-        {
-            DEBUG("Repository Database: " << data_dir);
-        }
+namespace rlxos::libpkgupd {
+class repodb : public db {
+   public:
+    repodb(std::string const &data_dir)
+        : db(data_dir) {
+        DEBUG("Repository Database: " << data_dir);
+    }
 
-          std::shared_ptr<pkginfo> operator[](std::string const &pkgid);
-    };
-}
+    std::shared_ptr<pkginfo> operator[](std::string const &pkgid);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/resolver.cc b/libpkgupd/resolver.cc
index 184ccfe..fc07f0d 100644
--- a/libpkgupd/resolver.cc
+++ b/libpkgupd/resolver.cc
@@ -1,45 +1,38 @@
 #include "resolver.hh"
-namespace rlxos::libpkgupd
-{
-    bool resolver::_to_skip(std::string const &pkgid)
-    {
-        if ((std::find(_data.begin(), _data.end(), pkgid) != _data.end()))
-            return true;
+namespace rlxos::libpkgupd {
+bool resolver::_to_skip(std::string const &pkgid) {
+    if ((std::find(_data.begin(), _data.end(), pkgid) != _data.end()))
+        return true;
+
+    if (_sysdb[pkgid] != nullptr)
+        return true;
 
-        if (_sysdb[pkgid] != nullptr)
-            return true;
+    if ((std::find(_visited.begin(), _visited.end(), pkgid) != _visited.end()))
+        return true;
 
-        if ((std::find(_visited.begin(), _visited.end(), pkgid) != _visited.end()))
-            return true;
+    _visited.push_back(pkgid);
+    return false;
+}
+bool resolver::resolve(std::string const &pkgid, bool all) {
+    if (_to_skip(pkgid))
+        return true;
 
-        _visited.push_back(pkgid);
+    auto pkginfo_ = _repodb[pkgid];
+    if (pkginfo_ == nullptr) {
+        _error = "missing required dependency '" + pkgid + "'";
         return false;
     }
-    bool resolver::resolve(std::string const &pkgid, bool all)
-    {
-
-        if (_to_skip(pkgid))
-            return true;
 
-        auto pkginfo_ = _repodb[pkgid];
-        if (pkginfo_ == nullptr)
-        {
-            _error = "missing required dependency '" + pkgid + "'";
+    for (auto const &i : pkginfo_->depends(all)) {
+        if (!resolve(i, all)) {
+            _error += "\n Trace Required by " + pkgid;
             return false;
         }
+    }
 
-        for (auto const &i : pkginfo_->depends(all))
-        {
-            if (!resolve(i, all))
-            {
-                _error += "\n Trace Required by " + pkgid;
-                return false;
-            }
-        }
-
-        if ((std::find(_data.begin(), _data.end(), pkgid) == _data.end()))
-            _data.push_back(pkgid);
+    if ((std::find(_data.begin(), _data.end(), pkgid) == _data.end()))
+        _data.push_back(pkgid);
 
-        return true;
-    }
-}
\ No newline at end of file
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/resolver.hh b/libpkgupd/resolver.hh
index 0dced1f..fefdca6 100644
--- a/libpkgupd/resolver.hh
+++ b/libpkgupd/resolver.hh
@@ -1,34 +1,31 @@
 #ifndef _LIBPKGUPD_RESOLVEDEPENDS_HH_
 #define _LIBPKGUPD_RESOLVEDEPENDS_HH_
 
+#include <functional>
+
 #include "defines.hh"
-#include "sysdb.hh"
 #include "repodb.hh"
+#include "sysdb.hh"
 
-#include <functional>
+namespace rlxos::libpkgupd {
+class resolver : public object {
+   private:
+    repodb &_repodb;
+    sysdb &_sysdb;
+    std::vector<std::string> _data, _visited;
+
+    bool _to_skip(std::string const &pkgid);
+
+   public:
+    resolver(repodb &rp, sysdb &sd)
+        : _repodb{rp},
+          _sysdb{sd} {
+    }
+
+    bool resolve(std::string const &pkgid, bool all = false);
 
-namespace rlxos::libpkgupd
-{
-    class resolver : public object
-    {
-    private:
-        repodb &_repodb;
-        sysdb &_sysdb;
-        std::vector<std::string> _data, _visited;
-
-        bool _to_skip(std::string const &pkgid);
-
-    public:
-        resolver(repodb &rp, sysdb &sd)
-            : _repodb{rp},
-              _sysdb{sd}
-        {
-        }
-
-        bool resolve(std::string const &pkgid, bool all = false);
-
-        GET_METHOD(std::vector<std::string>, data);
-    };
-}
+    GET_METHOD(std::vector<std::string>, data);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/stripper.cc b/libpkgupd/stripper.cc
index 774c9fe..3eb2474 100644
--- a/libpkgupd/stripper.cc
+++ b/libpkgupd/stripper.cc
@@ -1,45 +1,40 @@
 #include "stripper.hh"
-#include "exec.hh"
-
-namespace rlxos::libpkgupd
-{
-    stripper::stripper(std::vector<std::string> const &skips)
-    {
 
-        // Thanks to (VenomLinux - scratchpkg) https://github.com/emmeett1
-        // https://github.com/venomlinux/scratchpkg/blob/master/pkgbuild#L215
+#include "exec.hh"
 
-        if (skips.size())
-        {
-            _filter = "grep -v";
-            for (auto const &i : skips)
-                _filter += " -e " + i.substr(0, i.length() - 1);
-        }
+namespace rlxos::libpkgupd {
+stripper::stripper(std::vector<std::string> const &skips) {
+    // Thanks to (VenomLinux - scratchpkg) https://github.com/emmeett1
+    // https://github.com/venomlinux/scratchpkg/blob/master/pkgbuild#L215
 
-        _script = "find . -type f -printf \"%P\\n\" 2>/dev/null | " + _filter +
-                  " | while read -r binary ; do \n"
-                  " case \"$(file -bi \"$binary\")\" in \n"
-                  " *application/x-sharedlib*)      strip --strip-unneeded \"$binary\" ;; \n"
-                  " *application/x-pie-executable*) strip --strip-unneeded \"$binary\" ;; \n"
-                  " *application/x-archive*)        strip --strip-debug    \"$binary\" ;; \n"
-                  " *application/x-object*) \n"
-                  "    case \"$binary\" in \n"
-                  "     *.ko)                       strip --strip-unneeded \"$binary\" ;; \n"
-                  "     *)                          continue ;; \n"
-                  "    esac;; \n"
-                  " *application/x-executable*)     strip --strip-all \"$binary\" ;; \n"
-                  " *)                              continue ;; \n"
-                  " esac\n"
-                  " done\n";
+    if (skips.size()) {
+        _filter = "grep -v";
+        for (auto const &i : skips)
+            _filter += " -e " + i.substr(0, i.length() - 1);
     }
 
-    bool stripper::strip(std::string const &dir)
-    {
-        if (int status = exec().execute(_script, dir); status != 0)
-        {
-            _error = "strip script failed with exit code: " + std::to_string(status);
-            return false;
-        }
-        return true;
+    _script = "find . -type f -printf \"%P\\n\" 2>/dev/null | " + _filter +
+              " | while read -r binary ; do \n"
+              " case \"$(file -bi \"$binary\")\" in \n"
+              " *application/x-sharedlib*)      strip --strip-unneeded \"$binary\" ;; \n"
+              " *application/x-pie-executable*) strip --strip-unneeded \"$binary\" ;; \n"
+              " *application/x-archive*)        strip --strip-debug    \"$binary\" ;; \n"
+              " *application/x-object*) \n"
+              "    case \"$binary\" in \n"
+              "     *.ko)                       strip --strip-unneeded \"$binary\" ;; \n"
+              "     *)                          continue ;; \n"
+              "    esac;; \n"
+              " *application/x-executable*)     strip --strip-all \"$binary\" ;; \n"
+              " *)                              continue ;; \n"
+              " esac\n"
+              " done\n";
+}
+
+bool stripper::strip(std::string const &dir) {
+    if (int status = exec().execute(_script, dir); status != 0) {
+        _error = "strip script failed with exit code: " + std::to_string(status);
+        return false;
     }
-}
\ No newline at end of file
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/stripper.hh b/libpkgupd/stripper.hh
index 666f22f..2fc6630 100644
--- a/libpkgupd/stripper.hh
+++ b/libpkgupd/stripper.hh
@@ -3,21 +3,19 @@
 
 #include "defines.hh"
 
-namespace rlxos::libpkgupd
-{
-    class stripper : public object
-    {
-    private:
-        std::string _script;
-        std::string _filter = "cat";
+namespace rlxos::libpkgupd {
+class stripper : public object {
+   private:
+    std::string _script;
+    std::string _filter = "cat";
 
-    public:
-        stripper(std::vector<std::string> const &skips = {});
+   public:
+    stripper(std::vector<std::string> const &skips = {});
 
-        METHOD(std::string, script);
+    METHOD(std::string, script);
 
-        bool strip(std::string const &dir);
-    };
-}
+    bool strip(std::string const &dir);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/sysdb.cc b/libpkgupd/sysdb.cc
index b723f50..e169064 100644
--- a/libpkgupd/sysdb.cc
+++ b/libpkgupd/sysdb.cc
@@ -1,122 +1,107 @@
 #include "sysdb.hh"
 
-#include <ctime>
-#include <sys/stat.h>
 #include <string.h>
+#include <sys/stat.h>
+
+#include <ctime>
 #include <fstream>
 
-namespace rlxos::libpkgupd
-{
+namespace rlxos::libpkgupd {
 
-    sysdb::package::package(YAML::Node const &data, std::string const &file)
-    {
-        READ_VALUE(std::string, id);
-        READ_VALUE(std::string, version);
-        READ_VALUE(std::string, about);
+sysdb::package::package(YAML::Node const &data, std::string const &file) {
+    READ_VALUE(std::string, id);
+    READ_VALUE(std::string, version);
+    READ_VALUE(std::string, about);
 
-        READ_VALUE(std::string, installed_on);
+    READ_VALUE(std::string, installed_on);
 
-        READ_LIST(std::string, depends);
-        READ_LIST(std::string, files);
-    }
+    READ_LIST(std::string, depends);
+    READ_LIST(std::string, files);
+}
 
-    std::shared_ptr<pkginfo> sysdb::operator[](std::string const &pkgid)
-    {
-        auto datafile = _data_dir + "/" + pkgid;
-        if (!std::filesystem::exists(datafile))
-            return nullptr;
+std::shared_ptr<pkginfo> sysdb::operator[](std::string const &pkgid) {
+    auto datafile = _data_dir + "/" + pkgid;
+    if (!std::filesystem::exists(datafile))
+        return nullptr;
 
-        DEBUG("Found at: " << datafile);
+    DEBUG("Found at: " << datafile);
 
-        return std::make_shared<sysdb::package>(YAML::LoadFile(datafile), datafile);
-    }
+    return std::make_shared<sysdb::package>(YAML::LoadFile(datafile), datafile);
+}
 
-    bool sysdb::is_installed(std::shared_ptr<pkginfo> const &pkginfo)
-    {
-        if ((*this)[pkginfo->id()] == nullptr)
-            return false;
+bool sysdb::is_installed(std::shared_ptr<pkginfo> const &pkginfo) {
+    if ((*this)[pkginfo->id()] == nullptr)
+        return false;
 
-        return true;
-    }
+    return true;
+}
+
+bool sysdb::outdated(std::shared_ptr<pkginfo> const &pkginfo) {
+    auto installedPackage = (*this)[pkginfo->id()];
+    if (installedPackage == nullptr)
+        throw std::runtime_error(pkginfo->id() + " is missing in sysdb");
 
-    bool sysdb::outdated(std::shared_ptr<pkginfo> const &pkginfo)
-    {
-        auto installedPackage = (*this)[pkginfo->id()];
-        if (installedPackage == nullptr)
-            throw std::runtime_error(pkginfo->id() + " is missing in sysdb");
+    return (installedPackage->version() != pkginfo->version());
+}
 
-        return (installedPackage->version() != pkginfo->version());
+bool sysdb::remove(std::shared_ptr<pkginfo> const &pkginfo) {
+    auto installedPackage = (*this)[pkginfo->id()];
+    if (installedPackage == nullptr) {
+        _error = "no package with id " + pkginfo->id() + " is installed";
+        return false;
     }
 
-    bool sysdb::remove(std::shared_ptr<pkginfo> const &pkginfo)
-    {
-        auto installedPackage = (*this)[pkginfo->id()];
-        if (installedPackage == nullptr)
-        {
-            _error = "no package with id " + pkginfo->id() + " is installed";
-            return false;
-        }
+    std::string datafile = _data_dir + "/" + pkginfo->id();
+    std::error_code err;
+    std::filesystem::remove(datafile, err);
+    if (err) {
+        _error = err.message();
+        return false;
+    }
 
-        std::string datafile = _data_dir + "/" + pkginfo->id();
-        std::error_code err;
-        std::filesystem::remove(datafile, err);
-        if (err)
-        {
-            _error = err.message();
+    return true;
+}
+
+bool sysdb::add(std::shared_ptr<pkginfo> const &pkginfo, std::vector<std::string> const &files, std::string root, bool toupdate) {
+    try {
+        if (is_installed(pkginfo) && !outdated(pkginfo) && !toupdate) {
+            _error = pkginfo->id() + " " + pkginfo->version() + " is already registered in the system";
             return false;
         }
 
-        return true;
+        toupdate = outdated(pkginfo);
+    } catch (...) {
     }
 
-    bool sysdb::add(std::shared_ptr<pkginfo> const &pkginfo, std::vector<std::string> const &files, std::string root, bool toupdate)
-    {
-
-        try
-        {
-            if (is_installed(pkginfo) && !outdated(pkginfo) && !toupdate)
-            {
-                _error = pkginfo->id() + " " + pkginfo->version() + " is already registered in the system";
-                return false;
-            }
-
-            toupdate = outdated(pkginfo);
-        }
-        catch (...)
-        {
-        }
-
-        auto datafile = _data_dir + "/" + pkginfo->id();
+    auto datafile = _data_dir + "/" + pkginfo->id();
 
-        std::ofstream fileptr(datafile);
-        if (!fileptr.is_open())
-        {
-            _error = "failed to open sysdb to register " + pkginfo->id();
-            return false;
-        }
+    std::ofstream fileptr(datafile);
+    if (!fileptr.is_open()) {
+        _error = "failed to open sysdb to register " + pkginfo->id();
+        return false;
+    }
 
-        fileptr << "id: " << pkginfo->id() << std::endl
-                << "version: " << pkginfo->version() << std::endl
-                << "about: " << pkginfo->about() << std::endl;
+    fileptr << "id: " << pkginfo->id() << std::endl
+            << "version: " << pkginfo->version() << std::endl
+            << "about: " << pkginfo->about() << std::endl;
 
-        if (pkginfo->depends(false).size())
-        {
-            fileptr << "depends:" << std::endl;
-            for (auto const &i : pkginfo->depends(false))
-                fileptr << " - " << i << std::endl;
-        }
+    if (pkginfo->depends(false).size()) {
+        fileptr << "depends:" << std::endl;
+        for (auto const &i : pkginfo->depends(false))
+            fileptr << " - " << i << std::endl;
+    }
 
-        std::time_t t = std::time(0);
-        std::tm *now = std::localtime(&t);
+    std::time_t t = std::time(0);
+    std::tm *now = std::localtime(&t);
 
-        fileptr << "installed_on: " << (now->tm_year + 1900) << "/" << (now->tm_mon + 1) << "/" << (now->tm_mday) << " " << (now->tm_hour) << ":" << (now->tm_min) << std::endl;
+    fileptr << "installed_on: " << (now->tm_year + 1900) << "/" << (now->tm_mon + 1) << "/" << (now->tm_mday) << " " << (now->tm_hour) << ":" << (now->tm_min) << std::endl;
 
-        fileptr << "files:" << std::endl;
-        for (auto i : files)
-            fileptr << "  - " << i << std::endl;
+    fileptr << "files:" << std::endl;
+    for (auto i : files)
+        fileptr << "  - " << i << std::endl;
 
-        fileptr.close();
+    fileptr.close();
 
-        return true;
-    }
-}
\ No newline at end of file
+    return true;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/sysdb.hh b/libpkgupd/sysdb.hh
index d6e8534..19d7d52 100644
--- a/libpkgupd/sysdb.hh
+++ b/libpkgupd/sysdb.hh
@@ -1,58 +1,54 @@
 #ifndef _PKGUPD_SYSTEM_DATABASE_HH_
 #define _PKGUPD_SYSTEM_DATABASE_HH_
 
-#include "db.hh"
 #include <yaml-cpp/yaml.h>
 
-namespace rlxos::libpkgupd
-{
+#include "db.hh"
 
-    class sysdb : public db
-    {
+namespace rlxos::libpkgupd {
 
-    public:
-        class package : public pkginfo
-        {
-        private:
-            std::string _id;
-            std::string _version;
-            std::string _about;
+class sysdb : public db {
+   public:
+    class package : public pkginfo {
+       private:
+        std::string _id;
+        std::string _version;
+        std::string _about;
 
-            std::vector<std::string> _depends,
-                _files;
+        std::vector<std::string> _depends,
+            _files;
 
-            std::string _installed_on;
+        std::string _installed_on;
 
-            std::string _required_by;
+        std::string _required_by;
 
-        public:
-            package(YAML::Node const &data, std::string const &file);
+       public:
+        package(YAML::Node const &data, std::string const &file);
 
-            std::string id() const { return _id; }
-            std::string version() const { return _version; }
-            std::string about() const { return _about; }
-            std::vector<std::string> depends(bool) const { return _depends; }
+        std::string id() const { return _id; }
+        std::string version() const { return _version; }
+        std::string about() const { return _about; }
+        std::vector<std::string> depends(bool) const { return _depends; }
 
-            GET_METHOD(std::vector<std::string>, files);
-            GET_METHOD(std::string, installed_on);
-            GET_METHOD(std::string, required_by);
-        };
-        sysdb(std::string const &d)
-            : db(d)
-        {
-            DEBUG("System Database: " << _data_dir);
-        }
+        GET_METHOD(std::vector<std::string>, files);
+        GET_METHOD(std::string, installed_on);
+        GET_METHOD(std::string, required_by);
+    };
+    sysdb(std::string const &d)
+        : db(d) {
+        DEBUG("System Database: " << _data_dir);
+    }
 
-        std::shared_ptr<pkginfo> operator[](std::string const &pkgid);
+    std::shared_ptr<pkginfo> operator[](std::string const &pkgid);
 
-        bool is_installed(std::shared_ptr<pkginfo> const &pkginfo);
+    bool is_installed(std::shared_ptr<pkginfo> const &pkginfo);
 
-        bool outdated(std::shared_ptr<pkginfo> const &pkginfo);
+    bool outdated(std::shared_ptr<pkginfo> const &pkginfo);
 
-        bool add(std::shared_ptr<pkginfo> const &pkginfo, std::vector<std::string> const &files, std::string root, bool update = false);
+    bool add(std::shared_ptr<pkginfo> const &pkginfo, std::vector<std::string> const &files, std::string root, bool update = false);
 
-        bool remove(std::shared_ptr<pkginfo> const &pkginfo);
-    };
-}
+    bool remove(std::shared_ptr<pkginfo> const &pkginfo);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/libpkgupd/triggerer.cc b/libpkgupd/triggerer.cc
index 1a3263b..7c4720d 100644
--- a/libpkgupd/triggerer.cc
+++ b/libpkgupd/triggerer.cc
@@ -1,34 +1,30 @@
 #include "triggerer.hh"
-#include "exec.hh"
 
-#include <iostream>
 #include <algorithm>
+#include <iostream>
 #include <regex>
 
-namespace rlxos::libpkgupd
-{
+#include "exec.hh"
 
-    triggerer::type triggerer::_get(std::string const &path)
-    {
-        for (auto const &i : {type::MIME, type::DESKTOP, type::FONTS_SCALE,
-                              type::UDEV, type::ICONS, type::GTK3_INPUT_MODULES,
-                              type::GTK2_INPUT_MODULES, type::GLIB_SCHEMAS, type::GIO_MODULES,
-                              type::GDK_PIXBUF, type::FONTS_CACHE})
-        {
-            std::string pattern = _regex(i);
-            if (std::regex_match(path, std::regex(pattern)))
-                return i;
-        }
+namespace rlxos::libpkgupd {
 
-        return type::INVALID;
+triggerer::type triggerer::_get(std::string const &path) {
+    for (auto const &i : {type::MIME, type::DESKTOP, type::FONTS_SCALE,
+                          type::UDEV, type::ICONS, type::GTK3_INPUT_MODULES,
+                          type::GTK2_INPUT_MODULES, type::GLIB_SCHEMAS, type::GIO_MODULES,
+                          type::GDK_PIXBUF, type::FONTS_CACHE}) {
+        std::string pattern = _regex(i);
+        if (std::regex_match(path, std::regex(pattern)))
+            return i;
     }
 
-    bool triggerer::_exec(type t)
-    {
-        std::string cmd;
+    return type::INVALID;
+}
+
+bool triggerer::_exec(type t) {
+    std::string cmd;
 
-        switch (t)
-        {
+    switch (t) {
         case type::MIME:
             cmd = "update-mime-database + /usr/share/mime";
             break;
@@ -65,11 +61,9 @@ namespace rlxos::libpkgupd
             cmd = "fc-cache -s";
             break;
 
-        case type::FONTS_SCALE:
-        {
+        case type::FONTS_SCALE: {
             bool status = true;
-            for (auto const &i : std::filesystem::directory_iterator("/usr/share/fonts"))
-            {
+            for (auto const &i : std::filesystem::directory_iterator("/usr/share/fonts")) {
                 std::filesystem::remove(i.path() / "fonts.scale");
                 std::filesystem::remove(i.path() / "fonts.dir");
                 std::filesystem::remove(i.path() / ".uuid");
@@ -77,14 +71,12 @@ namespace rlxos::libpkgupd
                 if (std::filesystem::is_empty(i.path()))
                     std::filesystem::remove(i.path());
 
-                if (int status = exec().execute("mkfontdir " + i.path().string()); status != 0)
-                {
+                if (int status = exec().execute("mkfontdir " + i.path().string()); status != 0) {
                     _error += "mkfontdir failed with exit code: " + std::to_string(status);
                     status = false;
                 }
 
-                if (int status = exec().execute("mkfontscale " + i.path().string()); status != 0)
-                {
+                if (int status = exec().execute("mkfontscale " + i.path().string()); status != 0) {
                     _error += "mkfontscale failed with exit code: " + std::to_string(status);
                     status = false;
                 }
@@ -93,14 +85,10 @@ namespace rlxos::libpkgupd
             return status;
         }
 
-        case type::ICONS:
-        {
+        case type::ICONS: {
             bool status = true;
-            for (auto const &i : std::filesystem::directory_iterator("/usr/share/icons"))
-            {
-
-                if (int status = exec().execute("gtk-update-icon-cache -q " + i.path().string()); status != 0)
-                {
+            for (auto const &i : std::filesystem::directory_iterator("/usr/share/icons")) {
+                if (int status = exec().execute("gtk-update-icon-cache -q " + i.path().string()); status != 0) {
                     _error += "gtk-update-icon-cahce failed with exit code: " + std::to_string(status);
                     status = false;
                 }
@@ -110,22 +98,19 @@ namespace rlxos::libpkgupd
         }
         default:
             throw std::runtime_error("unimplemented trigger executed");
-        }
-
-        if (int status = exec().execute(cmd); status != 0)
-        {
-            _error += "trigger failed with exit code: " + std::to_string(status);
-            status = false;
-        }
+    }
 
-        return true;
+    if (int status = exec().execute(cmd); status != 0) {
+        _error += "trigger failed with exit code: " + std::to_string(status);
+        status = false;
     }
 
-    std::string triggerer::_regex(type t)
-    { // Thanks to venomLinux scratch package manager
-        // https://github.com/venomlinux/scratchpkg/blob/master/scratch#L284
-        switch (t)
-        {
+    return true;
+}
+
+std::string triggerer::_regex(type t) {  // Thanks to venomLinux scratch package manager
+    // https://github.com/venomlinux/scratchpkg/blob/master/scratch#L284
+    switch (t) {
         case type::MIME:
             return "^./usr/share/mime/$";
 
@@ -158,17 +143,15 @@ namespace rlxos::libpkgupd
 
         case type::FONTS_CACHE:
             return "^./usr/share/fonts/$";
-        }
-
-        throw std::runtime_error("unimplemented trigger found in triggerer::triggerRegex()");
     }
 
-    std::string triggerer::_mesg(type t)
-    {
-        // Thanks to venomLinux scratch package manager
-        // https://github.com/venomlinux/scratchpkg/blob/master/scratch#L284
-        switch (t)
-        {
+    throw std::runtime_error("unimplemented trigger found in triggerer::triggerRegex()");
+}
+
+std::string triggerer::_mesg(type t) {
+    // Thanks to venomLinux scratch package manager
+    // https://github.com/venomlinux/scratchpkg/blob/master/scratch#L284
+    switch (t) {
         case type::MIME:
             return "Updating MIME database";
         case type::DESKTOP:
@@ -191,67 +174,57 @@ namespace rlxos::libpkgupd
             return "Probing GDK Pixbuf loader modules";
         case type::FONTS_CACHE:
             return "Updating fontconfig cache";
-        }
-
-        throw std::runtime_error("unimplemented trigger found in triggerer::getMessage()");
     }
 
-    std::vector<triggerer::type> triggerer::_get(std::vector<std::vector<std::string>> const &fileslist)
-    {
-        std::vector<triggerer::type> requiredTriggers;
-        for (auto i : {type::MIME, type::DESKTOP, type::FONTS_SCALE,
-                       type::UDEV, type::ICONS, type::GTK3_INPUT_MODULES,
-                       type::GTK2_INPUT_MODULES, type::GLIB_SCHEMAS, type::GIO_MODULES,
-                       type::GDK_PIXBUF, type::FONTS_CACHE})
-        {
-            for (auto const &pkgfiles : fileslist)
-            {
-                if (std::find(requiredTriggers.begin(), requiredTriggers.end(), i) == requiredTriggers.end())
+    throw std::runtime_error("unimplemented trigger found in triggerer::getMessage()");
+}
+
+std::vector<triggerer::type> triggerer::_get(std::vector<std::vector<std::string>> const &fileslist) {
+    std::vector<triggerer::type> requiredTriggers;
+    for (auto i : {type::MIME, type::DESKTOP, type::FONTS_SCALE,
+                   type::UDEV, type::ICONS, type::GTK3_INPUT_MODULES,
+                   type::GTK2_INPUT_MODULES, type::GLIB_SCHEMAS, type::GIO_MODULES,
+                   type::GDK_PIXBUF, type::FONTS_CACHE}) {
+        for (auto const &pkgfiles : fileslist) {
+            if (std::find(requiredTriggers.begin(), requiredTriggers.end(), i) == requiredTriggers.end())
+                break;
+
+            for (auto const &file : pkgfiles) {
+                auto trigger = _get(file);
+                if (trigger != type::INVALID) {
+                    requiredTriggers.push_back(trigger);
                     break;
-
-                for (auto const &file : pkgfiles)
-                {
-                    auto trigger = _get(file);
-                    if (trigger != type::INVALID)
-                    {
-                        requiredTriggers.push_back(trigger);
-                        break;
-                    }
                 }
             }
         }
-
-        return requiredTriggers;
     }
 
-    bool triggerer::trigger(std::vector<std::vector<std::string>> const &fileslist)
-    {
-        if (fileslist.size() == 0)
-            return true;
-
-        bool status = true;
-        auto requiredTriggers = _get(fileslist);
-        for (auto const &i : requiredTriggers)
-        {
-            PROCESS(_mesg(i))
-
-            if (!_exec(i))
-            {
-                _error += "\n" + _error;
-                status = false;
-            }
-        }
+    return requiredTriggers;
+}
 
-        {
+bool triggerer::trigger(std::vector<std::vector<std::string>> const &fileslist) {
+    if (fileslist.size() == 0)
+        return true;
 
-            PROCESS("Updating library cache");
+    bool status = true;
+    auto requiredTriggers = _get(fileslist);
+    for (auto const &i : requiredTriggers) {
+        PROCESS(_mesg(i))
 
-            if (int status = exec().execute("/bin/ldconfig"); status != 0)
-            {
-                _error = "failed to update library cache";
-                return false;
-            }
+        if (!_exec(i)) {
+            _error += "\n" + _error;
+            status = false;
+        }
+    }
+
+    {
+        PROCESS("Updating library cache");
+
+        if (int status = exec().execute("/bin/ldconfig"); status != 0) {
+            _error = "failed to update library cache";
+            return false;
         }
-        return status;
     }
-}
\ No newline at end of file
+    return status;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/libpkgupd/triggerer.hh b/libpkgupd/triggerer.hh
index 3afa0e3..49b8207 100644
--- a/libpkgupd/triggerer.hh
+++ b/libpkgupd/triggerer.hh
@@ -3,44 +3,40 @@
 
 #include "defines.hh"
 
-namespace rlxos::libpkgupd
-{
-    class triggerer : public object
-    {
-    private:
-        enum class type : int
-        {
-            INVALID,
-            MIME,
-            DESKTOP,
-            FONTS_SCALE,
-            HARDWARE,
-            UDEV,
-            ICONS,
-            GTK3_INPUT_MODULES,
-            GTK2_INPUT_MODULES,
-            GLIB_SCHEMAS,
-            GIO_MODULES,
-            GDK_PIXBUF,
-            FONTS_CACHE,
-        };
-
-        std::string _mesg(type t);
-
-        std::string _regex(type t);
-
-        type _get(std::string const &path);
-
-        bool _exec(type t);
-
-        std::vector<type> _get(std::vector<std::vector<std::string>> const &fileslist);
-
-    public:
-        triggerer()
-        {
-        }
-        bool trigger(std::vector<std::vector<std::string>> const &fileslist);
+namespace rlxos::libpkgupd {
+class triggerer : public object {
+   private:
+    enum class type : int {
+        INVALID,
+        MIME,
+        DESKTOP,
+        FONTS_SCALE,
+        HARDWARE,
+        UDEV,
+        ICONS,
+        GTK3_INPUT_MODULES,
+        GTK2_INPUT_MODULES,
+        GLIB_SCHEMAS,
+        GIO_MODULES,
+        GDK_PIXBUF,
+        FONTS_CACHE,
     };
-}
+
+    std::string _mesg(type t);
+
+    std::string _regex(type t);
+
+    type _get(std::string const &path);
+
+    bool _exec(type t);
+
+    std::vector<type> _get(std::vector<std::vector<std::string>> const &fileslist);
+
+   public:
+    triggerer() {
+    }
+    bool trigger(std::vector<std::vector<std::string>> const &fileslist);
+};
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/pkgupd/PKGUPD.cc b/pkgupd/PKGUPD.cc
index b509345..3d43801 100644
--- a/pkgupd/PKGUPD.cc
+++ b/pkgupd/PKGUPD.cc
@@ -3,66 +3,57 @@
 #include <bits/stdc++.h>
 using namespace std;
 
-namespace rlxos::libpkgupd
-{
-
-    bool PKGUPD::_need_atleast(int size)
-    {
-        if (_args.size() < size)
-        {
-            ERROR("Need alteast " << std::to_string(size) << " arguments");
-            return false;
-        }
+namespace rlxos::libpkgupd {
 
-        return true;
+bool PKGUPD::_need_atleast(int size) {
+    if (_args.size() < size) {
+        ERROR("Need alteast " << std::to_string(size) << " arguments");
+        return false;
     }
 
-    bool PKGUPD::_need_args(int size)
-    {
-        if (_args.size() != size)
-        {
-            ERROR("Need " << size << " arguments");
-            return false;
-        }
+    return true;
+}
 
-        return true;
-    }
-    void PKGUPD::_print_help(char const *path)
-    {
-        cout << "Usage: " << path << " [TASK] [ARGS]... [PKGS]..\n"
-             << "PKGUPD is a system package manager for rlxos.\n"
-                "Perfrom system level package transactions like installations, upgradations and removal.\n\n"
-                "TASK:\n"
-                "  in,  install                 download and install specified package(s) from repository into the system\n"
-                "  rm,  remove                  remove specified package(s) from the system if already installed\n"
-                "  rf,  refresh                 synchronize local data with repositories\n"
-                "  up,  update                  upgarde specified package(s) to their latest avaliable version\n"
-                "  co,  compile                 try to compile specified package(s) from repository recipe files\n"
-                "  deptest                      perform dependencies test for specified package\n"
-                "  info                         print information of specified package\n"
-                "\n"
-                "To override default values simply pass argument as VALUE_NAME=VALUE\n"
-                "Avaliable Values:\n"
-                "  config                       override default configuration files path\n"
-                "  download-url                 override primary repository url\n"
-                "  secondary-download-url       override secondary repository url\n"
-             << "  " << SYS_DB << "                       override default system database\n"
-             << "  " << REPO_DB << "                      override default repository database path\n"
-             << "\n"
-             << "Exit Status:\n"
-                "  0  if OK\n"
-                "  1  if issue with input data provided.\n"
-                "\n"
-                "Full documentation <https://docs.rlxos.dev/pkgupd>\n"
-                "or local manual: man pkgupd"
-             << endl;
+bool PKGUPD::_need_args(int size) {
+    if (_args.size() != size) {
+        ERROR("Need " << size << " arguments");
+        return false;
     }
 
-    void PKGUPD::_parse_args(int ac, char **av)
-    {
-
-        switch (av[1][0])
-        {
+    return true;
+}
+void PKGUPD::_print_help(char const *path) {
+    cout << "Usage: " << path << " [TASK] [ARGS]... [PKGS]..\n"
+         << "PKGUPD is a system package manager for rlxos.\n"
+            "Perfrom system level package transactions like installations, upgradations and removal.\n\n"
+            "TASK:\n"
+            "  in,  install                 download and install specified package(s) from repository into the system\n"
+            "  rm,  remove                  remove specified package(s) from the system if already installed\n"
+            "  rf,  refresh                 synchronize local data with repositories\n"
+            "  up,  update                  upgarde specified package(s) to their latest avaliable version\n"
+            "  co,  compile                 try to compile specified package(s) from repository recipe files\n"
+            "  deptest                      perform dependencies test for specified package\n"
+            "  info                         print information of specified package\n"
+            "\n"
+            "To override default values simply pass argument as VALUE_NAME=VALUE\n"
+            "Avaliable Values:\n"
+            "  config                       override default configuration files path\n"
+            "  download-url                 override primary repository url\n"
+            "  secondary-download-url       override secondary repository url\n"
+         << "  " << SYS_DB << "                       override default system database\n"
+         << "  " << REPO_DB << "                      override default repository database path\n"
+         << "\n"
+         << "Exit Status:\n"
+            "  0  if OK\n"
+            "  1  if issue with input data provided.\n"
+            "\n"
+            "Full documentation <https://docs.rlxos.dev/pkgupd>\n"
+            "or local manual: man pkgupd"
+         << endl;
+}
+
+void PKGUPD::_parse_args(int ac, char **av) {
+    switch (av[1][0]) {
         case 'i':
             !(strcmp(av[1], "in") && (strcmp(av[1], "install")))
                 ? _task = task::INSTALL
@@ -97,151 +88,123 @@ namespace rlxos::libpkgupd
 
         default:
             _task = task::INVLAID;
-        }
+    }
 
-        for (int i = 2; i < ac; i++)
-        {
-            string arg(av[i]);
+    for (int i = 2; i < ac; i++) {
+        string arg(av[i]);
 
-            if (arg[0] == '-' && arg[1] == '-' && arg.length() > 2)
-                if (_aval_flags.find(arg.substr(2, arg.length() - 2)) == _aval_flags.end())
-                    throw std::runtime_error("invalid flag " + arg);
-                else
-                    _flags.push_back(_aval_flags[arg.substr(2, arg.length() - 2)]);
+        if (arg[0] == '-' && arg[1] == '-' && arg.length() > 2)
+            if (_aval_flags.find(arg.substr(2, arg.length() - 2)) == _aval_flags.end())
+                throw std::runtime_error("invalid flag " + arg);
             else
-            {
-                size_t idx = arg.find_first_of('=');
-                if (idx == string::npos)
-                    _args.push_back(arg);
-                else
-                    _values[arg.substr(0, idx)] = arg.substr(idx + 1, arg.length() - (idx + 1));
-            }
+                _flags.push_back(_aval_flags[arg.substr(2, arg.length() - 2)]);
+        else {
+            size_t idx = arg.find_first_of('=');
+            if (idx == string::npos)
+                _args.push_back(arg);
+            else
+                _values[arg.substr(0, idx)] = arg.substr(idx + 1, arg.length() - (idx + 1));
         }
     }
+}
 
-    string PKGUPD::_get_value(string var, string def)
-    {
-        if (_values.find(var) != _values.end())
-            return _values[var];
+string PKGUPD::_get_value(string var, string def) {
+    if (_values.find(var) != _values.end())
+        return _values[var];
 
-        if (_config[var])
-            return _config[var].as<std::string>();
+    if (_config[var])
+        return _config[var].as<std::string>();
 
-        return def;
+    return def;
+}
+
+int PKGUPD::exec(int ac, char **av) {
+    if (ac == 1) {
+        _print_help(av[0]);
+        return 0;
     }
 
-    int PKGUPD::exec(int ac, char **av)
-    {
-        if (ac == 1)
-        {
-            _print_help(av[0]);
-            return 0;
-        }
+    try {
+        _parse_args(ac, av);
+    } catch (std::exception const &ee) {
+        cerr << ee.what() << endl;
+        return 1;
+    }
 
-        try
-        {
-            _parse_args(ac, av);
-        }
-        catch (std::exception const &ee)
-        {
-            cerr << ee.what() << endl;
+    if (_values.find("config") != _values.end()) {
+        if (!std::filesystem::exists(_values["config"])) {
+            ERROR("Error! provided configuration file '" + _values["config"] + "' not exist");
             return 1;
         }
 
-        if (_values.find("config") != _values.end())
-        {
-            if (!std::filesystem::exists(_values["config"]))
-            {
-                ERROR("Error! provided configuration file '" + _values["config"] + "' not exist");
-                return 1;
-            }
-
-            _config_file = _values["config"];
-        }
-        else
-        {
-            for (auto const &i : {"pkgupd.yml", "/etc/pkgupd.yml"})
-            {
-                if (std::filesystem::exists(i))
-                {
-                    _config_file = i;
-                    break;
-                }
+        _config_file = _values["config"];
+    } else {
+        for (auto const &i : {"pkgupd.yml", "/etc/pkgupd.yml"}) {
+            if (std::filesystem::exists(i)) {
+                _config_file = i;
+                break;
             }
         }
+    }
 
-        if (std::filesystem::exists(_config_file))
-            _config = YAML::LoadFile(_config_file);
-
-        if (_config["environ"])
-        {
-            for (auto const &e : _config["environ"])
-            {
-                DEBUG("exporting " << e.as<string>());
-                auto env = e.as<string>();
-                size_t idx = env.find_first_of("=");
-                setenv(env.substr(0, idx).c_str(), env.substr(idx + 1, env.length() - (idx + 1)).c_str(), 1);
-            }
+    if (std::filesystem::exists(_config_file))
+        _config = YAML::LoadFile(_config_file);
+
+    if (_config["environ"]) {
+        for (auto const &e : _config["environ"]) {
+            DEBUG("exporting " << e.as<string>());
+            auto env = e.as<string>();
+            size_t idx = env.find_first_of("=");
+            setenv(env.substr(0, idx).c_str(), env.substr(idx + 1, env.length() - (idx + 1)).c_str(), 1);
         }
+    }
 
-        auto sysdb_ = sysdb(_get_value(SYS_DB, DEFAULT_DATA_DIR));
-        auto repodb_ = repodb(_get_value(REPO_DB, DEFAULT_REPO_DIR));
+    auto sysdb_ = sysdb(_get_value(SYS_DB, DEFAULT_DATA_DIR));
+    auto repodb_ = repodb(_get_value(REPO_DB, DEFAULT_REPO_DIR));
 
-        auto downloader_ = downloader();
+    auto downloader_ = downloader();
 
-        downloader_.urls({DEFAULT_URL, DEFAULT_SECONDARY_URL});
+    downloader_.urls({DEFAULT_URL, DEFAULT_SECONDARY_URL});
 
-        auto installer_ = installer(sysdb_, repodb_, downloader_, _get_value(PKG_DIR, DEFAULT_PKGS_DIR));
+    auto installer_ = installer(sysdb_, repodb_, downloader_, _get_value(PKG_DIR, DEFAULT_PKGS_DIR));
 
-        switch (_task)
-        {
-        case task::INSTALL:
-        {
+    switch (_task) {
+        case task::INSTALL: {
             if (!_need_atleast(1))
                 return 1;
 
             std::vector<std::string> to_install;
-            if (!_is_flag(flag::SKIP_DEPENDS))
-            {
+            if (!_is_flag(flag::SKIP_DEPENDS)) {
                 PROCESS("resolving dependencies")
-                for (auto const &i : _args)
-                {
+                for (auto const &i : _args) {
                     auto resolver_ = resolver(repodb_, sysdb_);
-                    if (!resolver_.resolve(i))
-                    {
+                    if (!resolver_.resolve(i)) {
                         ERROR(resolver_.error());
                         return 2;
                     }
                     to_install.insert(to_install.end(), resolver_.data().begin(), resolver_.data().end());
                 }
-            }
-            else
-            {
+            } else {
                 to_install = _args;
             }
 
-            if (!installer_.install(to_install, _get_value(ROOT_DIR, DEFAULT_ROOT_DIR), _is_flag(flag::SKIP_TRIGGER), _is_flag(flag::FORCE)))
-            {
+            if (!installer_.install(to_install, _get_value(ROOT_DIR, DEFAULT_ROOT_DIR), _is_flag(flag::SKIP_TRIGGER), _is_flag(flag::FORCE))) {
                 ERROR(installer_.error());
                 return 2;
             }
 
             return 0;
-        }
-        break;
-        case task::COMPILE:
-        {
+        } break;
+        case task::COMPILE: {
             if (!_need_args(1))
                 return 1;
 
             std::shared_ptr<recipe> recipe_;
             if (std::filesystem::exists(_args[0]))
                 recipe_ = recipe::from_filepath(_args[0]);
-            else
-            {
+            else {
                 auto pkg = repodb_[_args[0]];
-                if (pkg == nullptr)
-                {
+                if (pkg == nullptr) {
                     ERROR(repodb_.error());
                     return 2;
                 }
@@ -250,29 +213,24 @@ namespace rlxos::libpkgupd
             }
             auto builder_ = builder(_get_value("work-dir", "/tmp"), _get_value(PKG_DIR, DEFAULT_PKGS_DIR), _get_value(SRC_DIR, DEFAULT_SRC_DIR), _is_flag(flag::FORCE));
 
-            if (!builder_.build(recipe_))
-            {
+            if (!builder_.build(recipe_)) {
                 ERROR(builder_.error());
                 return 2;
             }
 
-            if (!installer_.install(builder_.archive_list(), _get_value(ROOT_DIR, DEFAULT_ROOT_DIR), _is_flag(flag::SKIP_TRIGGER), _is_flag(flag::FORCE)))
-            {
+            if (!installer_.install(builder_.archive_list(), _get_value(ROOT_DIR, DEFAULT_ROOT_DIR), _is_flag(flag::SKIP_TRIGGER), _is_flag(flag::FORCE))) {
                 ERROR(installer_.error());
                 return 2;
             }
 
             return 0;
-        }
-        break;
-        case task::INFO:
-        {
+        } break;
+        case task::INFO: {
             _need_args(1);
 
             std::shared_ptr<pkginfo> pkginfo_;
             pkginfo_ = sysdb_[_args[0]];
-            if (pkginfo_ != nullptr)
-            {
+            if (pkginfo_ != nullptr) {
                 auto sys_pkginfo = std::dynamic_pointer_cast<sysdb::package>(pkginfo_);
                 cout << "id            : " << sys_pkginfo->id() << "\n"
                      << "version       : " << sys_pkginfo->version() << "\n"
@@ -284,14 +242,11 @@ namespace rlxos::libpkgupd
             }
 
             pkginfo_ = repodb_[_args[0]];
-            if (pkginfo_ == nullptr)
-            {
-                if (std::filesystem::exists(_args[0]))
-                {
+            if (pkginfo_ == nullptr) {
+                if (std::filesystem::exists(_args[0])) {
                     auto archive_ = archive(_args[0]);
                     pkginfo_ = archive_.info();
-                    if (pkginfo_ == nullptr)
-                    {
+                    if (pkginfo_ == nullptr) {
                         ERROR(archive_.error());
                         return 2;
                     }
@@ -302,9 +257,7 @@ namespace rlxos::libpkgupd
                          << "about         : " << archive_pkginfo->about() << endl;
 
                     return 0;
-                }
-                else
-                {
+                } else {
                     ERROR(repodb_.error());
                     return 2;
                 }
@@ -317,41 +270,33 @@ namespace rlxos::libpkgupd
                  << "provided by   : " << repo_pkginfo->parent()->id() << endl;
 
             return 0;
-        }
-        break;
+        } break;
 
-        case task::REMOVE:
-        {
+        case task::REMOVE: {
             auto remover_ = remover(sysdb_, _get_value(ROOT_DIR, DEFAULT_ROOT_DIR));
             std::vector<std::string> _to_remove;
-            for (auto const &i : _args)
-            {
+            for (auto const &i : _args) {
                 if (sysdb_[i] != nullptr)
                     _to_remove.push_back(i);
                 else
                     INFO(i << " is not already installed");
             }
-            if (!remover_.remove(_to_remove, _is_flag(flag::SKIP_TRIGGER)))
-            {
+            if (!remover_.remove(_to_remove, _is_flag(flag::SKIP_TRIGGER))) {
                 ERROR(remover_.error());
                 return 2;
             }
 
             return 0;
-        }
-        break;
+        } break;
 
-        case task::DEPTEST:
-        {
+        case task::DEPTEST: {
             _need_atleast(1);
 
             std::vector<std::string> list;
             PROCESS("checking dependencies")
-            for (auto const &i : _args)
-            {
+            for (auto const &i : _args) {
                 auto resolver_ = resolver(repodb_, sysdb_);
-                if (!resolver_.resolve(i, _is_flag(flag::FORCE)))
-                {
+                if (!resolver_.resolve(i, _is_flag(flag::FORCE))) {
                     ERROR(resolver_.error());
                     return 2;
                 }
@@ -367,49 +312,38 @@ namespace rlxos::libpkgupd
                 std::cout << i << std::endl;
 
             return 0;
-        }
-        break;
+        } break;
 
-        case task::REFRESH:
-        {
+        case task::REFRESH: {
             PROCESS("refreshing repository");
-            if (!downloader_.get("recipe", "/tmp/.rcp"))
-            {
+            if (!downloader_.get("recipe", "/tmp/.rcp")) {
                 ERROR(downloader_.error());
                 return 2;
             }
 
-            try
-            {
+            try {
                 auto node = YAML::LoadFile("/tmp/.rcp");
                 std::error_code ee;
-                if (std::filesystem::exists(repodb_.data_dir()))
-                {
+                if (std::filesystem::exists(repodb_.data_dir())) {
                     std::filesystem::remove_all(repodb_.data_dir(), ee);
-                    if (ee)
-                    {
+                    if (ee) {
                         ERROR(ee.message());
                         return 2;
                     }
 
                     std::filesystem::create_directories(repodb_.data_dir(), ee);
-                    if (ee)
-                    {
+                    if (ee) {
                         ERROR(ee.message());
                         return 2;
                     }
                 }
 
-                for (auto const &i : node["recipes"])
-                {
-
-                    if (i["id"])
-                    {
+                for (auto const &i : node["recipes"]) {
+                    if (i["id"]) {
                         std::string id = i["id"].as<string>();
                         DEBUG("found " << id);
                         std::ofstream file(repodb_.data_dir() + "/" + id + ".yml");
-                        if (!file.is_open())
-                        {
+                        if (!file.is_open()) {
                             ERROR("failed to open file in " + repodb_.data_dir() + " to write recipe file for " + id);
                             return 2;
                         }
@@ -418,18 +352,15 @@ namespace rlxos::libpkgupd
                         file.close();
                     }
                 }
-            }
-            catch (YAML::Exception const &ee)
-            {
+            } catch (YAML::Exception const &ee) {
                 ERROR(ee.what());
                 return 2;
             }
 
             return 0;
-        }
-        break;
-        }
-
-        return 2;
+        } break;
     }
-}
\ No newline at end of file
+
+    return 2;
+}
+}  // namespace rlxos::libpkgupd
\ No newline at end of file
diff --git a/pkgupd/PKGUPD.hh b/pkgupd/PKGUPD.hh
index e4ed60e..e610823 100644
--- a/pkgupd/PKGUPD.hh
+++ b/pkgupd/PKGUPD.hh
@@ -1,82 +1,79 @@
 #ifndef _PKGUPD_HH_
 #define _PKGUPD_HH_
 
+#include <yaml-cpp/yaml.h>
+
+#include <map>
 #include <string>
 #include <vector>
-#include <map>
-#include <yaml-cpp/yaml.h>
+
 #include "../libpkgupd/libpkgupd.hh"
 
-namespace rlxos::libpkgupd
-{
-
-    class PKGUPD
-    {
-    public:
-        enum class task : int
-        {
-            INVLAID,
-            INSTALL,
-            COMPILE,
-            REMOVE,
-            REFRESH,
-            UPDATE,
-            DEPTEST,
-            INFO
-        };
-
-        enum class flag : int
-        {
-            FORCE,
-            SKIP_TRIGGER,
-            SKIP_DEPENDS,
-            NO_INSTALL,
-            REPOSITORY,
-        };
-
-    private:
-        task _task;
-
-        std::map<std::string, flag> _aval_flags{
-            {"force", flag::FORCE},
-            {"skip-triggers", flag::SKIP_TRIGGER},
-            {"skip-depends", flag::SKIP_DEPENDS},
-            {"no-install", flag::NO_INSTALL},
-            {"repository", flag::REPOSITORY},
-        };
-
-        std::vector<flag> _flags;
-        std::vector<std::string> _args;
-        std::map<std::string, std::string> _values;
-
-        YAML::Node _config;
-
-        std::string SYS_DB = "sys-db";
-        std::string REPO_DB = "repo-db";
-        std::string PKG_DIR = "pkg-dir";
-        std::string SRC_DIR = "src-dir";
-        std::string ROOT_DIR = "root-dir";
-
-        std::string _config_file = "/etc/pkgupd.yml";
-
-        void _print_help(char const *path);
-
-        void _parse_args(int ac, char **av);
-
-        bool _need_atleast(int size);
-        bool _need_args(int size);
-
-        std::string _get_value(std::string var, std::string def);
-
-        bool _is_flag(flag f)
-        {
-            return (std::find(_flags.begin(), _flags.end(), f) != _flags.end());
-        }
-
-    public:
-        int exec(int ac, char **av);
+namespace rlxos::libpkgupd {
+
+class PKGUPD {
+   public:
+    enum class task : int {
+        INVLAID,
+        INSTALL,
+        COMPILE,
+        REMOVE,
+        REFRESH,
+        UPDATE,
+        DEPTEST,
+        INFO
+    };
+
+    enum class flag : int {
+        FORCE,
+        SKIP_TRIGGER,
+        SKIP_DEPENDS,
+        NO_INSTALL,
+        REPOSITORY,
+    };
+
+   private:
+    task _task;
+
+    std::map<std::string, flag> _aval_flags{
+        {"force", flag::FORCE},
+        {"skip-triggers", flag::SKIP_TRIGGER},
+        {"skip-depends", flag::SKIP_DEPENDS},
+        {"no-install", flag::NO_INSTALL},
+        {"repository", flag::REPOSITORY},
     };
 
-}
+    std::vector<flag> _flags;
+    std::vector<std::string> _args;
+    std::map<std::string, std::string> _values;
+
+    YAML::Node _config;
+
+    std::string SYS_DB = "sys-db";
+    std::string REPO_DB = "repo-db";
+    std::string PKG_DIR = "pkg-dir";
+    std::string SRC_DIR = "src-dir";
+    std::string ROOT_DIR = "root-dir";
+
+    std::string _config_file = "/etc/pkgupd.yml";
+
+    void _print_help(char const *path);
+
+    void _parse_args(int ac, char **av);
+
+    bool _need_atleast(int size);
+    bool _need_args(int size);
+
+    std::string _get_value(std::string var, std::string def);
+
+    bool _is_flag(flag f) {
+        return (std::find(_flags.begin(), _flags.end(), f) != _flags.end());
+    }
+
+   public:
+    int exec(int ac, char **av);
+};
+
+}  // namespace rlxos::libpkgupd
 
 #endif
\ No newline at end of file
diff --git a/pkgupd/main.cc b/pkgupd/main.cc
index 4de775c..a2c210a 100644
--- a/pkgupd/main.cc
+++ b/pkgupd/main.cc
@@ -1,6 +1,5 @@
 #include "PKGUPD.hh"
 
-int main(int ac, char **av)
-{
+int main(int ac, char **av) {
     return rlxos::libpkgupd::PKGUPD().exec(ac, av);
 }
\ No newline at end of file
-- 
2.30.2

